global parse_input = int[] null;
global parse_input_length = 0;
global parse_pos = 0;

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_lt = 60;
global char_gt = 62;

/*
Strings are stored as int[] for easy manipulation.

AST nodes (XML tags) are stored as int[][], where node[0][0]
is the length of outermost array. This is effectively
a string[], but those are hard to get the length of.

To allow parsing nested tags, the position of the ">" of
the opening tag is stored in node[0][1], and the position
of the "<" of the closing tag is stored in node[0][2]. For
self closing tags node[0][1] and node[0][2] both contain
the position of the only ">".

node[1] contains the name of the tag.
node[1 + 2 * i] contains the name of the i-th attribue (starting at 0).
node[2 + 2 * i] contains the value of the i-th attribute.
*/

/* assert will segfault if the passed condition is false */
void assert(bool condition) {
  if (condition) {
    return;
  }
  var a = new int[0];
  a[123456789] = 1;
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      return false;
    }
  }
  return true;
}

/*
didive calculates (n / d).
If the resulting value is not an integer, divide fails.
Not all values of n and d are supported.
*/
int divide(int n, int d) {
  assert((n >= 0) & (d > 0));
  var x = 0;
  while (x * d < n) {
    x = x + 1;
  }
  assert(x * d == n);
  return x;
}

bool take_whitespace() {
  var did_take = false;
  while (parse_pos < parse_input_length) {
    var c = parse_input[parse_pos];
    if (c != char_tab & c != char_lf & c != char_cr & c != char_space) {
      return did_take;
    }
    did_take = true;
    parse_pos = parse_pos + 1;
  }
  return did_take;
}

bool take_this(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  var i = 0;
  while (parse_pos < parse_input_length) {
    if (parse_input[parse_pos] != chars[i]) {
      return false;
    }
    i = i + 1;
    parse_pos = parse_pos + 1;
    if (i == len) {
      return true;
    }
  }
  return i == len;
}

int[] take_from_ranges(string ranges) {
  var range_chars = array_of_string(ranges);
  var range_count = divide(length_of_string(ranges), 2);

  var start_pos = parse_pos;
  var count = 0;
  var unmatched = false;
  while (!unmatched & parse_pos < parse_input_length) {
    var c = parse_input[parse_pos];
    var matched_now = false;

    for (var i = 0; !matched_now & i < range_count; i = i + 1;) {
      if (c >= range_chars[2 * i] & c <= range_chars[2 * i + 1]) {
        matched_now = true;
      }
    }

    if (matched_now) {
      count = count + 1;
    } else {
      unmatched = true;
    }
    parse_pos = parse_pos + 1;
  }

  parse_pos = start_pos + count;
  var out = new int[count];
  for (var i = 0; i < count; i = i + 1;) {
    out[i] = parse_input[start_pos + i];
  }
  return out;
}

int[][] parse_tag() {
  assert(take_this("<"));
  take_whitespace();
  var tag_name = take_from_ranges("az");
  take_whitespace();

  var before_first_close = parse_pos;
  var is_self_closing = take_this("/");
  parse_pos = before_first_close;
  
  /* TODO parse attributes */

  var attr_count = 0;
  var node_len = 2 + 2 * attr_count;
  var output = new int[][node_len];
  output[0] = new int[]{node_len, 0, 0};
  output[1] = tag_name;

  if (is_self_closing) {
    assert(take_this("/"));
    take_whitespace();
    var close_pos = parse_pos;
    assert(take_this(">"));

    output[0][1] = close_pos;
    output[0][2] = close_pos;
    return output;
  } else {
    var first_close_pos = parse_pos;
    assert(take_this(">"));

    take_whitespace();
    parse_tag();
    take_whitespace();

    var second_open_pos = parse_pos;
    assert(take_this("<"));
    take_whitespace();
    assert(take_this("/"));
    take_whitespace();
    assert(take_this(string_of_array(tag_name)));
    take_whitespace();
    assert(take_this(">"));

    output[0][1] = first_close_pos;
    output[0][2] = second_open_pos;
    return output;
  }
}

string node_get_name(int[][] node) {
  var len = node[0][0];
  assert(len >= 2);
  return string_of_array(node[1]);
}

int node_get_attr_count(int[][] node) {
  var len = node[0][0];
  assert(len >= 2);
  return divide((len - 2), 2);
}

void load_input(string s) {
  parse_input = array_of_string(s);
  parse_input_length = length_of_string(s);
  parse_pos = 0;
  return;
}

void test_str_eq() {
  assert(str_eq("abc", "abc"));
  assert(str_eq("", ""));
  assert(!(str_eq("abc", "ab"))); /* TODO remove useless brackets once compiler supports it */
  assert(!(str_eq("ab", "abc"))); /* TODO remove useless brackets once compiler supports it */
  assert(!(str_eq("seal", "walrus"))); /* TODO remove useless brackets once compiler supports it */
  return;
}

void test_divide() {
  assert(divide(0, 1) == 0);
  assert(divide(0, 5) == 0);
  assert(divide(1, 1) == 1);
  assert(divide(2, 1) == 2);
  assert(divide(6, 3) == 2);
  assert(divide(100, 20) == 5);
  return;
}

void test_take_from_ranges_single(string input, string ranges, int taken) {
  load_input(input);
  take_from_ranges(ranges);
  assert(parse_pos == taken);
  return;
}

void test_take_from_ranges() {
  test_take_from_ranges_single("walrus", "az", 6);
  test_take_from_ranges_single("Walrus", "az", 0);
  test_take_from_ranges_single("Walrus", "azAZ", 6);
  test_take_from_ranges_single("1==1", "<>09", 4);
  test_take_from_ranges_single("1==1", "<>19", 4);
  test_take_from_ranges_single("1==1", "<>29", 0);
  test_take_from_ranges_single("1==1", "<>01", 4);
  test_take_from_ranges_single("1==1", "<>00", 0);
  return;
}

void test_parse_rect() {
  load_input("<rect />");
  var tag = parse_tag();
  assert(parse_pos == parse_input_length);
  assert(node_get_attr_count(tag) == 0);
  assert(str_eq(node_get_name(tag), "rect"));
  return;
}

void test_parse_nested() {
  load_input("<parent><child /></parent>");
  var tag = parse_tag();
  assert(parse_pos == parse_input_length);
  assert(node_get_attr_count(tag) == 0);
  assert(tag[0][1] == 7);
  assert(tag[0][2] == 17);
  assert(str_eq(node_get_name(tag), "parent"));
  return;
}

void test_parse_various() {
  var inputs = new string[]{
    "<rect />",
    "<  rect   /   >",
    "<parent><child/></parent>",
    "<  parent > <   child /   > < /  parent >",
    "<parent><child><another/></child></parent>"
  };
  var count = 5;

  for (var i = 0; i < count; i = i + 1;) {
    load_input(inputs[i]);
    parse_tag();
    assert(parse_pos == parse_input_length);
  }
  return;
}

void run_tests() {
  test_str_eq();
  test_divide();
  test_take_from_ranges();
  test_parse_rect();
  test_parse_nested();
  test_parse_various();
  return;
}

int program (int argc, string[] argv) {
  run_tests(); /* TODO remove in final submission */
  return 0;

  var input_string = "<rect />";

  parse_input = array_of_string(input_string);
  parse_input_length = length_of_string(input_string);

  take_whitespace();
  var tag = parse_tag();
  take_whitespace();

  return 0;
}
