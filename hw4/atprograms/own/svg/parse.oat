global parse_input = int[][]{int[] null};
global parse_input_length = 0;
global parse_pos = 0;

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_double_quote = 34;
global char_single_quote = 39;

global char_quote_arr = int[]{34};

/*
Strings are stored as int[] for easy manipulation.

AST nodes (XML tags) are stored as int[][], where node[0][0]
is the length of outermost array. This is effectively
a string[], but those are hard to get the length of.

To allow parsing nested tags, the position of the ">" of
the opening tag is stored in node[0][1], and the position
of the "<" of the closing tag is stored in node[0][2]. For
self closing tags node[0][1] and node[0][2] both contain
the position of the only ">".

node[1] contains the name of the tag.
node[1 + 2 * i] contains the name of the i-th attribue (starting at 0).
node[2 + 2 * i] contains the value of the i-th attribute.

Images are stored as int[], where img[0] is the width of the image and
img[1] is the height of the image. The pixel at x 12, y 53 (y down) is
stored in img[width * y + x].

Pixels are stored as rgba values, where each component is
in the range 0-255. The following bits of an int are used
to store each component (0 is LSB):

  63-32 unused
  31-24 red
  23-16 green
  15-8 blue
  7-0 alpha

This allows hex literals to be used like rgba hex colors (eg. 0xA611EEFF
is an opaque light purple).
*/

/* assert will segfault if the passed condition is false */
void assert(bool condition) {
  if (condition) {
    return;
  }
  var a = new int[0];
  a[123456789] = 1;
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      return false;
    }
  }
  return true;
}

int char_arr_len(int[] chars) {
  return length_of_string(string_of_array(chars));
}

/*
didive calculates (n / d).
If the resulting value is not an integer, divide fails.
Not all values of n and d are supported.
*/
int divide(int n, int d) {
  assert((n >= 0) & (d > 0));
  var x = 0;
  while (x * d < n) {
    x = x + 1;
  }
  assert(x * d == n);
  return x;
}

string convert_quotes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_single_quote) {
      chars[i] = char_double_quote;
    }
  }
  return string_of_array(chars);
}

int color_from_components(int r, int g, int b, int a) {
  assert((r >= 0) & (r < 256));
  assert((g >= 0) & (g < 256));
  assert((b >= 0) & (b < 256));
  assert((a >= 0) & (a < 256));
  return (r << 24) [|] (g << 16) [|] (b << 8) [|] a;
}

int color_get_r(int color) {
  return (color [&] 0xFF000000) >> 24;
}

int color_get_g(int color) {
  return (color [&] 0x00FF0000) >> 16;
}

int color_get_b(int color) {
  return (color [&] 0x0000FF00) >> 8;
}

int color_get_a(int color) {
  return color [&] 0x000000FF;
}

bool take_whitespace() {
  var did_take = false;
  while (parse_pos < parse_input_length) {
    var c = parse_input[0][parse_pos];
    if (c != char_tab & c != char_lf & c != char_cr & c != char_space) {
      return did_take;
    }
    did_take = true;
    parse_pos = parse_pos + 1;
  }
  return did_take;
}

bool take_this(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  var i = 0;
  while (parse_pos < parse_input_length) {
    if (parse_input[0][parse_pos] != chars[i]) {
      return false;
    }
    i = i + 1;
    parse_pos = parse_pos + 1;
    if (i == len) {
      return true;
    }
  }
  return i == len;
}

bool take_quote() {
  return take_this(string_of_array(char_quote_arr));
}

int[] take_from_ranges(string ranges) {
  var range_chars = array_of_string(ranges);
  var range_count = divide(length_of_string(ranges), 2);

  var start_pos = parse_pos;
  var count = 0;
  var unmatched = false;
  while (!unmatched & parse_pos < parse_input_length) {
    var c = parse_input[0][parse_pos];
    var matched_now = false;

    for (var i = 0; !matched_now & i < range_count; i = i + 1;) {
      if (c >= range_chars[2 * i] & c <= range_chars[2 * i + 1]) {
        matched_now = true;
      }
    }

    if (matched_now) {
      count = count + 1;
    } else {
      unmatched = true;
    }
    parse_pos = parse_pos + 1;
  }

  parse_pos = start_pos + count;
  var out = new int[count];
  for (var i = 0; i < count; i = i + 1;) {
    out[i] = parse_input[0][start_pos + i];
  }
  return out;
}

int[][] parse_attribute() {
  var old_pos = parse_pos;
  var failed = false;

  var name = take_from_ranges("azAZ--");
  failed = failed | char_arr_len(name) == 0;
  take_whitespace();
  failed = failed | !(take_this("=")); /* TODO remove useless brackets once compiler supports it */
  take_whitespace();
  failed = failed | !(take_quote());
  var value = take_from_ranges(" !#~");
  failed = failed | !(take_quote());


  if (failed) {
    parse_pos = old_pos;
    return new int[][]{new int[]{2}, new int[0]};
  }

  return new int[][]{new int[]{4}, new int[0], name, value};
}

int[][] parse_tag() {
  assert(take_this("<"));
  take_whitespace();
  var tag_name = take_from_ranges("az");
  take_whitespace();

  var before_attrs = parse_pos;
  var attr_count = 0;
  var maybe_more_attrs = true;
  while (maybe_more_attrs) {
    take_whitespace();
    var attr = parse_attribute();
    take_whitespace();

    if (node_get_attr_count(attr) == 0) {
      maybe_more_attrs = false;
    } else {
      attr_count = attr_count + 1;
    }
  }
  parse_pos = before_attrs;

  var node_len = 2 + 2 * attr_count;
  var output = new int[][node_len];
  output[0] = new int[]{node_len, 0, 0};
  output[1] = tag_name;

  for (var i = 0; i < attr_count; i = i + 1;) {
    take_whitespace();
    var attr = parse_attribute();
    take_whitespace();

    output[2 + 2 * i] = attr[2];
    output[2 + 2 * i + 1] = attr[3];
  }

  var before_first_close = parse_pos;
  var is_self_closing = take_this("/");
  parse_pos = before_first_close;

  if (is_self_closing) {
    assert(take_this("/"));
    take_whitespace();
    var close_pos = parse_pos;
    assert(take_this(">"));

    output[0][1] = close_pos;
    output[0][2] = close_pos;
    return output;
  } else {
    var first_close_pos = parse_pos;
    assert(take_this(">"));

    take_whitespace();
    parse_tag();
    take_whitespace();

    var second_open_pos = parse_pos;
    assert(take_this("<"));
    take_whitespace();
    assert(take_this("/"));
    take_whitespace();
    assert(take_this(string_of_array(tag_name)));
    take_whitespace();
    assert(take_this(">"));

    output[0][1] = first_close_pos;
    output[0][2] = second_open_pos;
    return output;
  }
}

string node_get_name(int[][] node) {
  var len = node[0][0];
  assert(len >= 2);
  return string_of_array(node[1]);
}

int node_get_attr_count(int[][] node) {
  var len = node[0][0];
  assert(len >= 2);
  return divide((len - 2), 2);
}

void load_input(string s) {
  parse_input[0] = array_of_string(s);
  parse_input_length = length_of_string(s);
  parse_pos = 0;
  return;
}

void test_str_eq() {
  assert(str_eq("abc", "abc"));
  assert(str_eq("", ""));
  assert(!(str_eq("abc", "ab"))); /* TODO remove useless brackets once compiler supports it */
  assert(!(str_eq("ab", "abc"))); /* TODO remove useless brackets once compiler supports it */
  assert(!(str_eq("seal", "walrus"))); /* TODO remove useless brackets once compiler supports it */
  return;
}

void test_divide() {
  assert(divide(0, 1) == 0);
  assert(divide(0, 5) == 0);
  assert(divide(1, 1) == 1);
  assert(divide(2, 1) == 2);
  assert(divide(6, 3) == 2);
  assert(divide(100, 20) == 5);
  return;
}

void test_color() {
  assert(color_from_components(0, 0, 0, 255) == 0x000000FF);
  assert(color_from_components(0, 0, 255, 0) == 0x0000FF00);
  assert(color_from_components(0, 255, 0, 0) == 0x00FF0000);
  assert(color_from_components(255, 0, 0, 0) == 0xFF000000);
  assert(color_from_components(1, 2, 3, 4) == 0x01020304);
  assert(color_from_components(128, 0, 13, 255) == 0x80000DFF);

  var c = color_from_components(128, 123, 48, 77);
  assert(color_get_r(c) == 128);
  assert(color_get_g(c) == 123);
  assert(color_get_b(c) == 48);
  assert(color_get_a(c) == 77);
  assert(c == color_from_components(color_get_r(c), color_get_g(c), color_get_b(c), color_get_a(c)));

  return;
}

void test_take_from_ranges_single(string input, string ranges, int taken) {
  load_input(input);
  take_from_ranges(ranges);
  assert(parse_pos == taken);
  return;
}

void test_take_from_ranges() {
  test_take_from_ranges_single("walrus", "az", 6);
  test_take_from_ranges_single("Walrus", "az", 0);
  test_take_from_ranges_single("Walrus", "azAZ", 6);
  test_take_from_ranges_single("Walrus!", "azAZ", 6);
  test_take_from_ranges_single("1==1", "<>09", 4);
  test_take_from_ranges_single("1==1", "<>19", 4);
  test_take_from_ranges_single("1==1", "<>29", 0);
  test_take_from_ranges_single("1==1", "<>01", 4);
  test_take_from_ranges_single("1==1", "<>00", 0);
  return;
}

void test_parse_attribute_single(string input, int taken, string name, string value) {
  load_input(convert_quotes(input));
  var attr = parse_attribute();
  assert(parse_pos == taken);
  if (taken == 0) {
    assert(node_get_attr_count(attr) == 0);
  } else {
    assert(node_get_attr_count(attr) == 1);
    assert(str_eq(string_of_array(attr[2]), name));
    assert(str_eq(string_of_array(attr[3]), value));
  }
  return;
}

void test_parse_attribute() {
  test_parse_attribute_single("color='blue'", 12, "color", "blue");
  test_parse_attribute_single("'color'='blue'", 0, "", "");
  test_parse_attribute_single("viewBox='0 10 50 20'", 20, "viewBox", "0 10 50 20");
  test_parse_attribute_single("iAmIn=' space   '", 17, "iAmIn", " space   ");
  test_parse_attribute_single("stroke-width='3'", 16, "stroke-width", "3");
  test_parse_attribute_single("stroke-width   =   '3'", 22, "stroke-width", "3");
  return;
}

void test_parse_rect() {
  load_input("<rect />");
  var tag = parse_tag();
  assert(parse_pos == parse_input_length);
  assert(node_get_attr_count(tag) == 0);
  assert(str_eq(node_get_name(tag), "rect"));
  return;
}

void test_parse_nested() {
  load_input("<parent><child /></parent>");
  var tag = parse_tag();
  assert(parse_pos == parse_input_length);
  assert(node_get_attr_count(tag) == 0);
  assert(tag[0][1] == 7);
  assert(tag[0][2] == 17);
  assert(str_eq(node_get_name(tag), "parent"));
  return;
}

void test_parse_circle() {
  var input = "<circle cx='15' cy='5' r='3' stroke='green'
    stroke-width='3' />";
  load_input(convert_quotes(input));
  var tag = parse_tag();
  assert(parse_pos == parse_input_length);
  assert(str_eq(node_get_name(tag), "circle"));
  assert(node_get_attr_count(tag) == 5);
  assert(str_eq(string_of_array(tag[2]), "cx"));
  assert(str_eq(string_of_array(tag[3]), "15"));
  assert(str_eq(string_of_array(tag[4]), "cy"));
  assert(str_eq(string_of_array(tag[5]), "5"));
  assert(str_eq(string_of_array(tag[6]), "r"));
  assert(str_eq(string_of_array(tag[7]), "3"));
  assert(str_eq(string_of_array(tag[8]), "stroke"));
  assert(str_eq(string_of_array(tag[9]), "green"));
  assert(str_eq(string_of_array(tag[10]), "stroke-width"));
  assert(str_eq(string_of_array(tag[11]), "3"));
  return;
}

void test_parse_various_tags() {
  var inputs = new string[]{
    "<rect />",
    /* "<rect></rect>", */ /* TODO fix this */
    "<  rect   /   >",
    "<parent><child/></parent>",
    "<  parent > <   child /   > < /  parent >",
    "<parent><child><another/></child></parent>",
    "<rect stroke  =   'blue'  stroke-width  = '3' / >",
    "<parent><child><another with='attr' /></child></parent>"
  };
  var count = 7;

  for (var i = 0; i < count; i = i + 1;) {
    load_input(convert_quotes(inputs[i]));
    parse_tag();
    assert(parse_pos == parse_input_length);
  }
  return;
}

void run_tests() {
  test_str_eq();
  test_divide();
  test_take_from_ranges();
  test_color();
  test_parse_attribute();
  test_parse_rect();
  test_parse_nested();
  test_parse_circle();
  test_parse_various_tags();
  return;
}

int program (int argc, string[] argv) {
  run_tests(); /* TODO remove in final submission */
  return 0;

  load_input("<rect />");

  take_whitespace();
  var tag = parse_tag();
  take_whitespace();

  return 0;
}
