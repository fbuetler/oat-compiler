/*
json
  element

element
  object
  array
  string
  number
  "true"
  "false"
  "null"

object
  '{' members '}'

members
  member
  member ',' members

member
  string ':' element

array
  '[' elements ']'

elements
  element
  element ',' elements

*/

struct Json {
  JsonObject? obj;
  JsonArray? arr;
  JsonString? str;
  JsonNumber? number;
  JsonBoolean? boolean;
  JsonNull? nil
}

struct JsonObject{
  JsonMember[] members
}

struct JsonMember {
  string str;
  Json element
}

struct JsonArray{
  Json[] element
}

struct JsonString{
  string str
}

struct JsonNumber{
  int number
}

struct JsonBoolean{
  bool boolean
}

struct JsonNull {
}

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_double_quote = 34;
global char_hash = 35;
global char_single_quote = 39;
global char_zero = 48;
global char_upper_a = 65;
global char_lower_a = 97;

/*********** BEGIN PARSER ***********/

/* ParseResult is returned from every parser */
struct ParseResult {
  ParseState input;
  Json? node;
  string? str;
  int count
}

/* ParseState is the input to every parser */
struct ParseState {
  int[] str;
  int pos
}

ParseState parse_state_of_string(string s) {
  return new ParseState { str = array_of_string(s); pos = 0 };
}

/*
must_parse_str asserts that the given ParseResult contains a string 
and advances the ParseState. It returns the string from the ParseResult.
*/
string must_parse_str(ParseResult res) {
  if? (string str = res.str) {
    assert(length_of_string(str) == res.count);
    res.input.pos = res.input.pos + res.count;
    return str;
  } else {
    assert(false);
    return "";
  }
}

/************ END PARSER ************/

string convert_quotes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_single_quote) {
      chars[i] = char_double_quote;
    }
  }
  return string_of_array(chars);
}

void print_obj(JsonObject tmp){
  return;
}

void print_array(JsonArray tmp){
  return;
}

void print_str(JsonString tmp){
  return;
}

void print_number(JsonNumber tmp){
  print_int(tmp.number);
  return;
}

void print_boolean(JsonBoolean tmp){
  print_bool(tmp.boolean);
  return;
}

string print_null(JsonNull tmp){
  return "null";
}

string print_json(Json? tmp){
  if? (Json j = tmp){
    if? (JsonObject obj = j.obj){
      print_obj(obj);
    }
    if? (JsonArray arr = j.arr){
      print_array(arr);
    }
    if? (JsonString str = j.str){
      print_str(str);
    }
    if? (JsonNumber number = j.number){
      print_number(number);
    } 
    if? (JsonBoolean boolean = j.boolean){
      print_boolean(boolean);
    }
    if? (JsonNull nil = j.nil){
      return print_null(nil);
    }
  }
  return "TODO"; 
}

global assert_disabled_for_test = false;
global would_fail_assert = false;

void await_assert() {
  if (assert_disabled_for_test) {
    print_string("already waiting for assert\n");
    assert_disabled_for_test = false;
    assert(false);
    return;
  }
  assert_disabled_for_test = true;
  would_fail_assert = false;
  return;
}

bool did_assert() {
  if (!assert_disabled_for_test) {
    print_string("not waiting for assert\n");
    assert(false);
    return false;
  }
  assert_disabled_for_test = false;
  return would_fail_assert;
}

void assert(bool condition) {
  if (assert_disabled_for_test) {
    would_fail_assert = would_fail_assert | !condition;
    return;
  }
  if (condition) {
    return;
  }
  var a = new int[0]{i -> 0};
  a[123456789] = 1;
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      return false;
    }
  }
  return true;
}

Json wrap_obj(JsonObject obj){
  return new Json {
    obj = obj;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_arr(JsonArray arr){
  return new Json {
    obj = JsonObject null;
    arr = arr;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_str(JsonString str){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = str;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_number(JsonNumber number){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = number;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_boolean(JsonBoolean boolean){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = boolean;
    nil = JsonNull null
  };
}

Json wrap_nil(JsonNull nil){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = nil
  };
}

void test_null(){
  assert(str_eq(
    print_json(wrap_nil(new JsonNull {})), "null"
  ));
  return;
}

void test_parse_helpers() {
  var state = parse_state_of_string("walrus");
  assert(length(state.str) == 6);
  assert(state.pos == 0);

  var output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  });
  assert(str_eq(output, "wal"));
  assert(state.pos == 3);

  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 2
  });
  assert(did_assert());

  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 0
  });
  assert(did_assert());

  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  });
  assert(str_eq(output, ""));
  assert(state.pos == 0);

  return;
}

void run_tests() {
  test_null();
  test_parse_helpers();

  if (assert_disabled_for_test) {
    /* await_assert() without matching did_assert() */
    assert_disabled_for_test = false;
    assert(false);
  }
  return;
}

int program(int argc, string[] argv) {
  run_tests();
  print_string("PASSED");

  var input = convert_quotes("
    {'menu': {
      'id': 'file',
      'value': 'File',
      'popup': {
        'menuitem': [
          {'value': 'New', 'onclick': 'CreateNewDoc()'},
          {'value': 'Open', 'onclick': 'OpenDoc()'},
          {'value': 'Close', 'onclick': 'CloseDoc()'}
        ]
      }
    }}
  ");
  /* print_string(input); */

  return 0;
}