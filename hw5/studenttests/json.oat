/*
json
  element

element
  object
  array
  string
  number
  "true"
  "false"
  "null"

object
  '{' members '}'

members
  member
  member ',' members

member
  string ':' element

array
  '[' elements ']'

elements
  element
  element ',' elements

*/

struct Json {
  JsonObject? obj;
  JsonArray? arr;
  JsonString? str;
  JsonNumber? number;
  JsonBoolean? boolean;
  JsonNull? nil
}

struct JsonObject{
  JsonMember[] members
}

struct JsonMember {
  string str;
  Json element
}

struct JsonArray{
  Json[] arr
}

struct JsonString{
  string str
}

struct JsonNumber{
  int number
}

struct JsonBoolean{
  bool boolean
}

struct JsonNull {
}

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_double_quote = 34;
global char_hash = 35;
global char_single_quote = 39;
global char_forward_slash = 47;
global char_zero = 48;
global char_upper_a = 65;
global char_backslash = 92;
global char_lower_a = 97;

global empty_json = new Json {
  obj = JsonObject null;
  arr = JsonArray null;
  str = JsonString null;
  number = JsonNumber null;
  boolean = JsonBoolean null;
  nil = JsonNull null
};

/*********** BEGIN HELPER ***********/

global assert_disabled_for_test = false;
global would_fail_assert = false;

void await_assert() {
  if (assert_disabled_for_test) {
    print_string("already waiting for assert\n");
    assert_disabled_for_test = false;
    assert(false);
    return;
  }
  assert_disabled_for_test = true;
  would_fail_assert = false;
  return;
}

bool did_assert() {
  if (!assert_disabled_for_test) {
    print_string("not waiting for assert\n");
    assert(false);
    return false;
  }
  assert_disabled_for_test = false;
  return would_fail_assert;
}

void assert(bool condition) {
  if (assert_disabled_for_test) {
    would_fail_assert = would_fail_assert | !condition;
    return;
  }
  if (condition) {
    return;
  }
  var a = new int[0]{i -> 0};
  a[123456789] = 1;
  return;
}

void print_int_array(int[] arr){
  for(var i=0;i<length(arr);i=i+1;){
    print_int(arr[i]);
    print_string(" ");
  }
  print_string("\n");
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      return false;
    }
  }
  return true;
}

/*********** END HELPER ***********/

/*********** BEGIN PARSER ***********/

/* ParseResult is returned from every parser */
struct ParseResult {
  ParseState input;
  Json? node;
  string? str;
  int count
}

/* ParseState is the input to every parser */
struct ParseState {
  int[] str;
  int pos
}

ParseState parse_state_of_string(string s) {
  return new ParseState { str = array_of_string(s); pos = 0 };
}

/*
must_parse_str asserts that the given ParseResult contains a string 
and advances the ParseState. It returns the string from the ParseResult.
*/
string must_parse_str(ParseResult res) {
  /* TODO if? else if? is broken in our compiler */
  if? (Json node = res.node) {
    assert(false);
    return "";
  }
  if? (string str = res.str) {
    assert(length_of_string(str) == res.count);
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return str;
  }
  assert(false);
  return "";
}

/*
must_parse_node asserts that the given ParseResult contains a JSON node
and advances the ParseState. It returns the Json struct from the ParseResult.
*/
Json must_parse_node(ParseResult res) {
  if? (string str = res.str) {
    assert(false);
    return empty_json;
  }
  if? (Json node = res.node) {
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return node;
  }
  assert(false);
  return empty_json;
}

/*
can_parse checks whether the given ParseResult would consume any
characters if applied with must_parse_string or must_parse_node.
*/
bool can_parse(ParseResult res) {
  return res.count > 0;
}

void ignore_str(string s) {
  return;
}

void ignore_node(Json node) {
  return;
}

ParseState copy_parse_state(ParseState state) {
  return new ParseState {
    str = new int[length(state.str)]{i -> state.str[i]};
    pos = state.pos
  };
}

ParseResult copy_parse_result(ParseResult res) {
  return new ParseResult {
    input = copy_parse_state(res.input);
    node = res.node;
    str = res.str;
    count = res.count
  };
}

ParseResult fail_parse(ParseState input) {
  return new ParseResult {
    input = input;
    node = Json null;
    str = string null;
    count = 0
  };
}

ParseResult parse_result_of_difference(ParseState before, ParseState after) {
  assert(before.pos <= after.pos);
  var out = int_vector_new();
  for (var i = before.pos; i < after.pos; i = i + 1;) {
    var b = before.str[i];
    var a = after.str[i];
    assert(a == b);
    out = int_vector_append(out, a);
  }
  return new ParseResult {
    input = before;
    node = Json null;
    str = string_of_array(array_of_int_vector(out));
    count = after.pos - before.pos
  };
}

/*
parse_this tries to read the supplied string from the input, and fails
if the string is not present exactly at the current position. Trailing
characters are not read.
*/
ParseResult parse_this(ParseState input, string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);

  /* TODO Something in the compiler crashes if you supply a value for a field which does not exist */
  var ok_result = new ParseResult {
    input = input;
    node = Json null;
    str = s;
    count = len
  };

  var i = 0;
  while (i + input.pos < length(input.str)) {
    if (input.str[i + input.pos] != chars[i]) {
      return fail_parse(input);
    }
    i = i + 1;
    if (i == len) {
      return ok_result;
    }
  }
  return fail_parse(input);
}

/* parse_quote reads exactly one literal " character */
ParseResult parse_quote(ParseState input) {
  return parse_this(input, string_of_array(new int[]{char_double_quote}));
}

/* parse_backslash reads exactly one literal \ character */
ParseResult parse_backslash(ParseState input) {
  return parse_this(input, string_of_array(new int[]{char_backslash}));
}

/*
parse_matching_chars reads a sequence of characters for which the 
callback returns true.
*/
ParseResult parse_matching_chars(ParseState input, (int) -> bool check_match) {
  var i = 0;
  var done = false;
  var output = int_vector_new();
  while (!done & (i + input.pos < length(input.str))) {
    var c = input.str[i + input.pos];
    if (check_match(c)) {
      i = i + 1;
      output = int_vector_append(output, c);
    } else {
      done = true;
    }
  }
  return new ParseResult {
    input = input;
    node = Json null;
    str = string_of_array(array_of_int_vector(output));
    count = output.len
  };
}

/* parse_matching_char reads exactly one character if it matches the callback. */
ParseResult parse_matching_char(ParseState input, (int) -> bool check_match) {
  if (input.pos >= length(input.str)) {
    return fail_parse(input);
  }
  var c = input.str[input.pos];
  if (!check_match(c)) {
    return fail_parse(input);
  }
  return new ParseResult {
    input = input;
    node = Json null;
    str = string_of_array(new int[]{c});
    count = 1
  };
}

bool is_whitespace_char(int c) {
  return c == char_tab | c == char_lf | c == char_cr | c == char_space;
}

/* parse_whitespace reads as many whitespace characters as possible. */
ParseResult parse_whitespace(ParseState input) {
  return parse_matching_chars(input, is_whitespace_char);
}

bool is_valid_unescaped_string_char(int c) {
  return c >= 32 & c <= 1114111 & c != char_double_quote;
}

bool is_valid_escaped_string_char(int c) {
  if (c == char_backslash) {
    return true;
  }
  var l = array_of_string(convert_quotes("'/bfnrtu"));
  for (var i = 0; i < length(l); i = i + 1;) {
    if (c == l[i]) {
      return true;
    }
  }
  return false;
}

bool is_char_in_string(string s, int c) {
  var l = array_of_string(s);
  for (var i = 0; i < length(l); i = i + 1;) {
    if (c == l[i]) {
      return true;
    }
  }
  return false;
}

bool is_valid_hex_char(int c) {
  return is_char_in_string("abcdefABCDEF0123456789", c);
}

bool is_valid_digit_char(int c) {
  return is_char_in_string("0123456789", c);
}

bool is_valid_exponent_e_char(int c) {
  return is_char_in_string("Ee", c);
}

bool is_valid_exponent_sign_char(int c) {
  return is_char_in_string("+-", c);
}

ParseResult parse_four_hex_digits(ParseState input) { 
  var state = copy_parse_state(input);
  for (var i = 0; i < 4; i = i + 1;) {
    var res = parse_matching_char(state, is_valid_hex_char);
    if (!can_parse(res)) {
      return fail_parse(input);
    }
    ignore_str(must_parse_str(res));
  }
  return parse_result_of_difference(input, state);
}

ParseResult parse_json_string_char(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_backslash(state);
  if (!can_parse(res)) {
    return parse_matching_char(input, is_valid_unescaped_string_char);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_char(state, is_valid_escaped_string_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  var escaped_char = must_parse_str(res);

  if (str_eq(escaped_char, "u")) {
    res = parse_four_hex_digits(state);
    if (!can_parse(res)) {
      return fail_parse(input);
    }
    ignore_str(must_parse_str(res));
  }

  return parse_result_of_difference(input, state);
}

/*
parse_json_string reads a JSON string. The output does not include the
surrounding quotes. All espace sequences are included in the output without
conversion (so \\ remains two slashes, and does not become one \).
*/
ParseResult parse_json_string(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_quote(state);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  var done = false;
  while (!done) {
    if (can_parse(parse_quote(state))) {
      done = true;
    } else {
      res = parse_json_string_char(state);
      if (!can_parse(res)) {
        return fail_parse(input);
      }
      ignore_str(must_parse_str(res));
    }
  }

  ignore_str(must_parse_str(parse_quote(state)));

  var out = int_vector_new();
  for (var i = input.pos + 1; i < state.pos - 1; i = i + 1;) {
    out = int_vector_append(out, input.str[i]);
  }
  return new ParseResult {
    input = input;
    node = wrap_str(new JsonString {
      str = string_of_array(array_of_int_vector(out))
    });
    str = string null;
    count = state.pos - input.pos
  };
}

/* parse_json_integer is a helper for parse_json_number */
ParseResult parse_json_integer(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_this(state, "-");
  var negative = can_parse(res);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }
  
  res = parse_matching_char(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  if (str_eq(must_parse_str(res), "0")) {
    return parse_result_of_difference(input, state);
  }

  state.pos = state.pos - 1;
  ignore_str(must_parse_str(parse_matching_chars(state, is_valid_digit_char)));

  return parse_result_of_difference(input, state);
}

/* parse_json_fraction is a helper for parse_json_number */
ParseResult parse_json_fraction(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_this(state, ".");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_chars(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  return parse_result_of_difference(input, state);
}

/* parse_json_exponent is a helper for parse_json_number */
ParseResult parse_json_exponent(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_matching_char(state, is_valid_exponent_e_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_char(state, is_valid_exponent_sign_char);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }

  res = parse_matching_chars(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  return parse_result_of_difference(input, state);
}

/*
parse_json_number reads a JSON number. The output is a string which contains
exactly the same characters as the JSON file did. The number is not evaluated
to an Oat int.
*/
ParseResult parse_json_number(ParseState input) {
  return fail_parse(input);
}

void test_must_parse_str() {
  var state = parse_state_of_string("walrus");
  assert(length(state.str) == 6);
  assert(state.pos == 0);

  /* Case: Typical parse */
  var output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  });
  assert(str_eq(output, "wal"));
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "r";
    count = 1
  });
  assert(str_eq(output, "r"));
  assert(state.pos == 4);

  /* Case: Count does not match string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 2
  });
  assert(did_assert());

  /* Case: Null string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Empty string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  });
  assert(did_assert());

  /* Case: Also contains JSON node */
  await_assert();
  output = must_parse_str(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wal";
    count = 3
  });
  assert(did_assert());

  return;
}

void test_must_parse_node() {
  /* Case: Typical */
  var state = parse_state_of_string("walrus");
  var output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  });
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 1
  });
  assert(state.pos == 4);

  /* Case: Null node */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Also contains string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wa";
    count = 2
  });
  assert(did_assert());

  return;
}

void test_can_parse() {
  var state = parse_state_of_string("walrus");

  /* Case: Typical node */
  assert(can_parse(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  }));

  /* Case: Typical string */
  assert(can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  }));

  /* Case: Empty string */
  assert(!can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  }));

  /* Case: Totally empty */
  assert(!can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 0
  }));

  return;
}

void assert_parse_string(ParseResult result, string expected) {
  assert(str_eq(must_parse_str(copy_parse_result(result)), expected));
  return;
}

void test_parse_this() {
  var state = parse_state_of_string("say walrus please");
  var output = must_parse_str(parse_this(state, "say w"));
  assert(str_eq(output, "say w"));
  assert(can_parse(parse_this(state, "alrus")));
  assert(!can_parse(parse_this(state, "walrus")));

  state = parse_state_of_string("say walrus please");
  assert_parse_string(parse_this(state, "say walrus please"), "say walrus please");
  assert_parse_string(parse_this(state, "say w"), "say w");
  assert_parse_string(parse_this(state, "s"), "s");
  assert(!can_parse(parse_this(state, "say walrus please ")));
  assert(!can_parse(parse_this(state, " say w")));
  assert(!can_parse(parse_this(state, "x")));

  return;
}

void test_parse_quote() {
  var state = parse_state_of_string(convert_quotes("Such '''testing''', right?"));
  assert(!can_parse(parse_quote(state)));
  ignore_str(must_parse_str(parse_this(state, "Such")));
  assert(!can_parse(parse_quote(state)));
  ignore_str(must_parse_str(parse_this(state, " ")));
  assert_parse_string(parse_quote(state), convert_quotes("'"));
  ignore_str(must_parse_str(parse_quote(state)));
  ignore_str(must_parse_str(parse_quote(state)));
  ignore_str(must_parse_str(parse_quote(state)));
  assert(!can_parse(parse_quote(state)));
  return;
}

void test_parse_whitespace() {
  var state = parse_state_of_string("   say
  
  
   walrus
please

");
  assert(str_eq(must_parse_str(parse_whitespace(state)), "   "));
  ignore_str(must_parse_str(parse_this(state, "say")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  ignore_str(must_parse_str(parse_this(state, "walrus")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  ignore_str(must_parse_str(parse_this(state, "please")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  assert(!can_parse(parse_whitespace(state)));
  return;
}

void test_parse_json_string() {
  var state = parse_state_of_string(convert_quotes("'walrus'"));
  var output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, "walrus"));
  } else {
    assert(false);
  }

  /*
  TODO Possible compiler bug: The folowing commented section does not work, but the
  uncommented one below it does. I think both piecs of code should behave the same way.
  */
  /* state = parse_state_of_string(convert_slashes(convert_quotes("'/n/n///txyz/''abc")));
  if? (string str = must_parse_node(parse_json_string(state)).str) {
    assert(str_eq(str.str, convert_slashes(convert_quotes("/n/n///txyz/'"))));
  } else {
    assert(false);
  } */

  state = parse_state_of_string(convert_slashes(convert_quotes("'/n/n///txyz/''abc")));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, convert_slashes(convert_quotes("/n/n///txyz/'"))));
  } else {
    assert(false);
  }

  state = parse_state_of_string(convert_slashes(convert_quotes("'/u1234/uABCD/uefAB/u0000'")));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, convert_slashes("/u1234/uABCD/uefAB/u0000")));
  } else {
    assert(false);
  }

  state = parse_state_of_string(convert_slashes(convert_quotes("'/u1234/uABCG/uefAB/u0000'")));
  assert(!can_parse(parse_json_string(state)));

  state = parse_state_of_string(convert_quotes("''"));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, ""));
  } else {
    assert(false);
  }

  return;
}

void test_parse_json_integer() {
  assert_parse_string(parse_json_integer(parse_state_of_string("123")), "123");
  assert_parse_string(parse_json_integer(parse_state_of_string("-123")), "-123");
  assert_parse_string(parse_json_integer(parse_state_of_string("0123")), "0");
  assert_parse_string(parse_json_integer(parse_state_of_string("-0123")), "-0");
  assert_parse_string(parse_json_integer(parse_state_of_string("-0123")), "-0");
  assert_parse_string(parse_json_integer(parse_state_of_string("0")), "0");
  assert_parse_string(parse_json_integer(parse_state_of_string("9")), "9");
  assert(!can_parse(parse_json_integer(parse_state_of_string(" 9"))));
  assert(!can_parse(parse_json_integer(parse_state_of_string("a9"))));
  assert(!can_parse(parse_json_integer(parse_state_of_string(".9"))));
  return;
}

void test_parse_json_fraction() {
  assert_parse_string(parse_json_fraction(parse_state_of_string(".123")), ".123");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".000")), ".000");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".0")), ".0");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".9")), ".9");
  assert(!can_parse(parse_json_integer(parse_state_of_string("."))));
  assert(!can_parse(parse_json_integer(parse_state_of_string("..123"))));
  assert_parse_string(parse_json_fraction(parse_state_of_string(".1.2.3")), ".1");
  return;
}

void test_parse_json_exponent() {
  assert_parse_string(parse_json_exponent(parse_state_of_string("e12")), "e12");
  assert_parse_string(parse_json_exponent(parse_state_of_string("e0000")), "e0000");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E1")), "E1");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E+12")), "E+12");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E-11")), "E-11");
  assert(!can_parse(parse_json_exponent(parse_state_of_string("12"))));
  assert(!can_parse(parse_json_exponent(parse_state_of_string("o12"))));
  assert(!can_parse(parse_json_exponent(parse_state_of_string("-12"))));
  return;
}

void test_parser(){
  test_must_parse_str();
  test_must_parse_node();
  test_can_parse();
  test_parse_this();
  test_parse_quote();
  test_parse_whitespace();
  test_parse_json_string();
  test_parse_json_integer();
  test_parse_json_fraction();
  test_parse_json_exponent();

  if (assert_disabled_for_test) {
    /* await_assert() without matching did_assert() */
    assert_disabled_for_test = false;
    assert(false);
  }
  return;
}

/************ END PARSER ************/

/*********** BEGIN VECTOR ***********/

struct IntVector {
  int[] data;
  int len;
  int capacity
}

IntVector int_vector_new() {
  var initialCapacity = 8;
  return new IntVector {
    data = new int[initialCapacity]{i -> 0};
    len = 0;
    capacity = initialCapacity
  };
}

int int_vector_get(IntVector vector, int index, int default) {
  if (index < 0 | index >= vector.len) {
    return default;
  }
  return vector.data[index];
}

IntVector int_vector_append(IntVector inVector, int value) {
  var outVector = inVector;
  if (inVector.len + 1 >= inVector.capacity) {
    var outCapacity = inVector.capacity * 2;
    outVector = new IntVector {
      data = new int[outCapacity]{i -> int_vector_get(inVector, i, 0)};
      len = inVector.len;
      capacity = outCapacity
    };
  }
  outVector.data[outVector.len] = value;
  outVector.len = outVector.len + 1;
  return outVector;
}

int[] array_of_int_vector(IntVector vector) {
  return new int[vector.len]{i -> vector.data[i]};
}

void test_vector() {
  var vec = int_vector_new();
  assert(vec.len == 0);
  vec = int_vector_append(vec, 1);
  vec = int_vector_append(vec, 8);
  vec = int_vector_append(vec, 3);
  assert(vec.len == 3);
  assert(vec.data[0] == 1);
  assert(vec.data[1] == 8);
  assert(vec.data[2] == 3);
  for (var i = 0; i < 100; i = i + 1;) {
    vec = int_vector_append(vec, 7);
  }
  assert(vec.len == 103);
  assert(vec.data[102] == 7);
  return;
}

/************ END VECTOR ************/

/*********** BEGIN PRINTER ***********/
global indent_size = "  ";

string convert_quotes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_single_quote) {
      chars[i] = char_double_quote;
    }
  }
  return string_of_array(chars);
}

string convert_slashes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_forward_slash) {
      chars[i] = char_backslash;
    }
  }
  return string_of_array(chars);
}

string print_indent(int depth){
  var indent = "";
  for(var i=0;i<depth;i=i+1;){
    indent = string_cat(indent, indent_size);
  }
  return indent;
}

string print_member(JsonMember tmp, int depth){
  var s = "'";
  s = string_cat(s, tmp.str);
  s = string_cat(s, "' : ");
  s = string_cat(s, print_json(tmp.element, depth));
  return convert_quotes(s);
}

string print_obj(JsonObject tmp, int depth){
  var s = "{\n";
  for(var i=0;i<length(tmp.members);i=i+1;){
    s = string_cat(s, print_indent(depth));
    s = string_cat(s, print_member(tmp.members[i], depth+1));
    if (i<length(tmp.members)-1){
      s = string_cat(s, ",");
    }
    s = string_cat(s, "\n");
  } 
  s = string_cat(s, print_indent(depth-1));
  s = string_cat(s, "}");
  return s;
}

string print_array(JsonArray tmp, int depth){
  var s = "[\n";
  for(var i=0;i<length(tmp.arr);i=i+1;){
    s = string_cat(s, print_indent(depth));
    s = string_cat(s, print_json(tmp.arr[i], depth+1));
    if (i<length(tmp.arr)-1){
      s = string_cat(s, ",");
    }
    s = string_cat(s, "\n");
  }
  s = string_cat(s, "]\n");
  return s;
}

string print_str(JsonString tmp){
  var s = "'";
  s = string_cat(s, tmp.str);
  s = string_cat(s, "'");
  return convert_quotes(s);
}

string print_number(JsonNumber tmp){
  if (tmp.number == 0) {
    return "0";
  }
  if (tmp.number == 1) {
    return "1";
  }
  if (tmp.number == 2) {
    return "2";
  }
  if (tmp.number == 3) {
    return "3";
  }
  if (tmp.number == 4) {
    return "4";
  }
  if (tmp.number == 5) {
    return "5";
  }
  if (tmp.number == 6) {
    return "6";
  }
  if (tmp.number == 7) {
    return "7";
  }
  if (tmp.number == 8) {
    return "8";
  }
  if (tmp.number == 9) {
    return "9";
  }
  return "TODO print_number";
}

string print_boolean(JsonBoolean tmp){
  if (tmp.boolean){
    return "true";
  }
  return "false";
}

string print_null(JsonNull tmp){
  return "null";
}

string print_json(Json? tmp, int depth){
  if? (Json j = tmp){
    if? (JsonObject obj = j.obj){
      return print_obj(obj, depth);
    }
    if? (JsonArray arr = j.arr){
      return print_array(arr, depth);
    }
    if? (JsonString str = j.str){
      return print_str(str);
    }
    if? (JsonNumber number = j.number){
      return print_number(number);
    } 
    if? (JsonBoolean boolean = j.boolean){
      return print_boolean(boolean);
    }
    if? (JsonNull nil = j.nil){
      return print_null(nil);
    }
  }
  return "TODO print_json"; 
}

Json wrap_obj(JsonObject obj){
  return new Json {
    obj = obj;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_arr(JsonArray arr){
  return new Json {
    obj = JsonObject null;
    arr = arr;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_str(JsonString str){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = str;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_number(JsonNumber number){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = number;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_boolean(JsonBoolean boolean){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = boolean;
    nil = JsonNull null
  };
}

Json wrap_nil(JsonNull nil){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = nil
  };
}

void test_obj(){
  var test1 = print_json(wrap_obj(
      new JsonObject{
        members = new JsonMember[]{
          new JsonMember{str = "hallo"; element = wrap_number(new JsonNumber {number = 3})}
        }
      }
    ), 1);

  var ref1 = convert_quotes(
"{
  'hallo' : 3
}");

  /* print_string(test1);
  print_string("\n");
  print_string(ref1);
  print_string("\n"); */

  assert(str_eq(test1, ref1));

  var test2 = print_json(wrap_obj(
      new JsonObject {
        members = new JsonMember[]{
          new JsonMember{
            str = "Team"; 
            element = wrap_obj(new JsonObject{
              members = new JsonMember[]{
                new JsonMember{str = "#1"; element = wrap_str(new JsonString {str = "Flo"})},
                new JsonMember{str = "#2"; element = wrap_str(new JsonString {str = "Philippe"})}
              }
            }) 
          },
          new JsonMember{
            str = "Animals"; 
            element = wrap_obj(new JsonObject{
              members = new JsonMember[]{
                new JsonMember{str = "#1"; element = wrap_str(new JsonString {str = "Panda"})},
                new JsonMember{str = "#2"; element = wrap_str(new JsonString {str = "Walrus"})}
              }
            }) 
          }
        }
      }
    ), 1);

  var ref2 = convert_quotes(
"{
  'Team' : {
    '#1' : 'Flo',
    '#2' : 'Philippe'
  },
  'Animals' : {
    '#1' : 'Panda',
    '#2' : 'Walrus'
  }
}");

  /* print_string(test2);
  print_string("\n");
  print_string(ref2);
  print_string("\n");
  assert(str_eq(test2, ref2)); */

  return;
}

void test_arr(){
  assert(str_eq(
    print_json(wrap_arr(
      new JsonArray {
        arr = new Json[]{
          wrap_number(new JsonNumber {number = 0}),
          wrap_number(new JsonNumber {number = 0}),
          wrap_number(new JsonNumber {number = 0})
         }
      }
    ), 1), 
"[
  0,
  0,
  0
]
"
  ));
  assert(str_eq(
    print_json(wrap_arr(
      new JsonArray {
        arr = new Json[]{
          wrap_number(new JsonNumber {number = 0}),
          wrap_boolean(new JsonBoolean {boolean = true}),
          wrap_boolean(new JsonBoolean {boolean = false}),
          wrap_nil(new JsonNull {})
         }
      }
    ), 1), 
"[
  0,
  true,
  false,
  null
]
"
  ));

  return;
}

void test_str(){
  assert(str_eq(
    print_json(wrap_str(
      new JsonString {
        str = "flooo"
      }
    ), 1),
    convert_quotes("'flooo'")
  ));
  assert(str_eq(
    print_json(wrap_str(
      new JsonString {
        str = "walrus"
      }
    ), 1),
    convert_quotes("'walrus'")
  ));

  return;
}

void test_number(){
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 0}), 0), "0"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 1}), 0), "1"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 2}), 0), "2"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 3}), 0), "3"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 4}), 0), "4"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 5}), 0), "5"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 6}), 0), "6"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 7}), 0), "7"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 8}), 0), "8"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = 9}), 0), "9"
  ));
  return;
}

void test_boolean(){
  assert(str_eq(
    print_json(wrap_boolean(new JsonBoolean {boolean = true}), 0), "true"
  ));
   assert(str_eq(
    print_json(wrap_boolean(new JsonBoolean {boolean = false}), 0), "false"
  ));
  return;
}

void test_null(){
  assert(str_eq(
    print_json(wrap_nil(new JsonNull {}), 0), "null"
  ));
  return;
}

void test_printer() {
  test_null();
  test_boolean();
  test_str();
  test_arr();
  test_obj();
  return;
}

/************ END PRINTER ************/

int program(int argc, string[] argv) {
  test_printer();
  test_parser();
  test_vector();
  print_string("PASSED");

  var input = convert_quotes("
    {'menu': {
      'id': 'file',
      'value': 'File',
      'popup': {
        'menuitem': [
          {'value': 'New', 'onclick': 'CreateNewDoc()'},
          {'value': 'Open', 'onclick': 'OpenDoc()'},
          {'value': 'Close', 'onclick': 'CloseDoc()'}
        ]
      }
    }}
  ");
  /* print_string(input); */

  return 0;
}