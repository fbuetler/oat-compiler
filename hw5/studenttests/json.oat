/*
17-913-534 Florian BÃ¼tler
16-926-560 Philippe Voinov
*/

struct Json {
  JsonObject? obj;
  JsonArray? arr;
  JsonString? str;
  JsonNumber? number;
  JsonBoolean? boolean;
  JsonNull? nil
}

struct JsonObject {
  JsonMember[] members
}

struct JsonMember {
  string str;
  Json element
}

struct JsonArray {
  Json[] arr
}

struct JsonString {
  string str
}

struct JsonNumber {
  string number
}

struct JsonBoolean {
  bool boolean
}

struct JsonNull {
}

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_double_quote = 34;
global char_hash = 35;
global char_single_quote = 39;
global char_forward_slash = 47;
global char_zero = 48;
global char_upper_a = 65;
global char_backslash = 92;
global char_lower_a = 97;

global empty_json = new Json {
  obj = JsonObject null;
  arr = JsonArray null;
  str = JsonString null;
  number = JsonNumber null;
  boolean = JsonBoolean null;
  nil = JsonNull null
};

global debug  = false;

/*********** BEGIN HELPER ***********/

global assert_disabled_for_test = false;
global would_fail_assert = false;

void await_assert() {
  if (assert_disabled_for_test) {
    print_string("already waiting for assert\n");
    assert_disabled_for_test = false;
    assert(false);
    return;
  }
  assert_disabled_for_test = true;
  would_fail_assert = false;
  return;
}

bool did_assert() {
  if (!assert_disabled_for_test) {
    print_string("not waiting for assert\n");
    assert(false);
    return false;
  }
  assert_disabled_for_test = false;
  return would_fail_assert;
}

void assert(bool condition) {
  if (assert_disabled_for_test) {
    would_fail_assert = would_fail_assert | !condition;
    return;
  }
  if (condition) {
    return;
  }
  var a = new int[0]{i -> 0};
  a[123456789] = 1;
  return;
}

void print_int_array(int[] arr){
  for(var i=0;i<length(arr);i=i+1;){
    print_int(arr[i]);
    print_string(" ");
  }
  print_string("\n");
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (debug){
    print_string("length of a: ");
    print_int(a_len);
    print_string("\n");
    print_string("length of b: ");
    print_int(b_len);
    print_string("\n");
  }
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);
  if (debug){
    print_string("arr a: ");
    print_int_array(a_chars);
    print_string("arr of b: ");
    print_int_array(a_chars);
  }

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      if(debug){
        print_string("first wrong position: ");
        print_int(i);
        print_string("\n");
      }
      return false;
    }
  }
  return true;
}

/*********** END HELPER ***********/

/*********** BEGIN PARSER ***********/

/* ParseResult is returned from every parser */
struct ParseResult {
  ParseState input;
  Json? node;
  string? str;
  int count
}

/* ParseState is the input to every parser */
struct ParseState {
  int[] str;
  int pos
}

ParseState parse_state_of_string(string s) {
  return new ParseState { str = array_of_string(s); pos = 0 };
}

/*
must_parse_str asserts that the given ParseResult contains a string 
and advances the ParseState. It returns the string from the ParseResult.
*/
string must_parse_str(ParseResult res) {
  /* TODO if? else if? is broken in our compiler */
  if? (Json node = res.node) {
    assert(false);
    return "";
  }
  if? (string str = res.str) {
    assert(length_of_string(str) == res.count);
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return str;
  }
  assert(false);
  return "";
}

/*
must_parse_node asserts that the given ParseResult contains a JSON node
and advances the ParseState. It returns the Json struct from the ParseResult.
*/
Json must_parse_node(ParseResult res) {
  if? (string str = res.str) {
    assert(false);
    return empty_json;
  }
  if? (Json node = res.node) {
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return node;
  }
  assert(false);
  return empty_json;
}

/*
can_parse checks whether the given ParseResult would consume any
characters if applied with must_parse_string or must_parse_node.
*/
bool can_parse(ParseResult res) {
  return res.count > 0;
}

void ignore_str(string s) {
  return;
}

void ignore_node(Json node) {
  return;
}

ParseState copy_parse_state(ParseState state) {
  return new ParseState {
    str = new int[length(state.str)]{i -> state.str[i]};
    pos = state.pos
  };
}

ParseResult copy_parse_result(ParseResult res) {
  return new ParseResult {
    input = copy_parse_state(res.input);
    node = res.node;
    str = res.str;
    count = res.count
  };
}

ParseResult fail_parse(ParseState input) {
  return new ParseResult {
    input = input;
    node = Json null;
    str = string null;
    count = 0
  };
}

ParseResult parse_result_of_difference(ParseState before, ParseState after) {
  assert(before.pos <= after.pos);
  var out = int_vector_new();
  for (var i = before.pos; i < after.pos; i = i + 1;) {
    var b = before.str[i];
    var a = after.str[i];
    assert(a == b);
    out = int_vector_append(out, a);
  }
  return new ParseResult {
    input = before;
    node = Json null;
    str = string_of_array(array_of_int_vector(out));
    count = after.pos - before.pos
  };
}

/*
parse_this tries to read the supplied string from the input, and fails
if the string is not present exactly at the current position. Trailing
characters are not read.
*/
ParseResult parse_this(ParseState input, string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);

  /* TODO Something in the compiler crashes if you supply a value for a field which does not exist */
  var ok_result = new ParseResult {
    input = input;
    node = Json null;
    str = s;
    count = len
  };

  var i = 0;
  while (i + input.pos < length(input.str)) {
    if (input.str[i + input.pos] != chars[i]) {
      return fail_parse(input);
    }
    i = i + 1;
    if (i == len) {
      return ok_result;
    }
  }
  return fail_parse(input);
}

/* parse_quote reads exactly one literal " character */
ParseResult parse_quote(ParseState input) {
  return parse_this(input, string_of_array(new int[]{char_double_quote}));
}

/* parse_backslash reads exactly one literal \ character */
ParseResult parse_backslash(ParseState input) {
  return parse_this(input, string_of_array(new int[]{char_backslash}));
}

/*
parse_matching_chars reads a sequence of characters for which the 
callback returns true.
*/
ParseResult parse_matching_chars(ParseState input, (int) -> bool check_match) {
  var i = 0;
  var done = false;
  var output = int_vector_new();
  while (!done & (i + input.pos < length(input.str))) {
    var c = input.str[i + input.pos];
    if (check_match(c)) {
      i = i + 1;
      output = int_vector_append(output, c);
    } else {
      done = true;
    }
  }
  return new ParseResult {
    input = input;
    node = Json null;
    str = string_of_array(array_of_int_vector(output));
    count = output.len
  };
}

/* parse_matching_char reads exactly one character if it matches the callback. */
ParseResult parse_matching_char(ParseState input, (int) -> bool check_match) {
  if (input.pos >= length(input.str)) {
    return fail_parse(input);
  }
  var c = input.str[input.pos];
  if (!check_match(c)) {
    return fail_parse(input);
  }
  return new ParseResult {
    input = input;
    node = Json null;
    str = string_of_array(new int[]{c});
    count = 1
  };
}

bool is_whitespace_char(int c) {
  return c == char_tab | c == char_lf | c == char_cr | c == char_space;
}

/* parse_whitespace reads as many whitespace characters as possible. */
ParseResult parse_whitespace(ParseState input) {
  return parse_matching_chars(input, is_whitespace_char);
}

/* try_parse applies a parsing function is possible */
void try_parse(ParseState input, (ParseState) -> ParseResult f) {
  var res = f(input);
  if (can_parse(res)) {
    input.pos = input.pos + res.count;
  }
  return;
}

bool is_valid_unescaped_string_char(int c) {
  return c >= 32 & c <= 1114111 & c != char_double_quote;
}

bool is_valid_escaped_string_char(int c) {
  if (c == char_backslash) {
    return true;
  }
  var l = array_of_string(convert_quotes("'/bfnrtu"));
  for (var i = 0; i < length(l); i = i + 1;) {
    if (c == l[i]) {
      return true;
    }
  }
  return false;
}

bool is_char_in_string(string s, int c) {
  var l = array_of_string(s);
  for (var i = 0; i < length(l); i = i + 1;) {
    if (c == l[i]) {
      return true;
    }
  }
  return false;
}

bool is_valid_hex_char(int c) {
  return is_char_in_string("abcdefABCDEF0123456789", c);
}

bool is_valid_digit_char(int c) {
  return is_char_in_string("0123456789", c);
}

bool is_valid_exponent_e_char(int c) {
  return is_char_in_string("Ee", c);
}

bool is_valid_exponent_sign_char(int c) {
  return is_char_in_string("+-", c);
}

ParseResult parse_four_hex_digits(ParseState input) { 
  var state = copy_parse_state(input);
  for (var i = 0; i < 4; i = i + 1;) {
    var res = parse_matching_char(state, is_valid_hex_char);
    if (!can_parse(res)) {
      return fail_parse(input);
    }
    ignore_str(must_parse_str(res));
  }
  return parse_result_of_difference(input, state);
}

ParseResult parse_json_string_char(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_backslash(state);
  if (!can_parse(res)) {
    return parse_matching_char(input, is_valid_unescaped_string_char);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_char(state, is_valid_escaped_string_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  var escaped_char = must_parse_str(res);

  if (str_eq(escaped_char, "u")) {
    res = parse_four_hex_digits(state);
    if (!can_parse(res)) {
      return fail_parse(input);
    }
    ignore_str(must_parse_str(res));
  }

  return parse_result_of_difference(input, state);
}

/*
parse_json_string reads a JSON string. The output does not include the
surrounding quotes. All espace sequences are included in the output without
conversion (so \\ remains two slashes, and does not become one \).
*/
ParseResult parse_json_string(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_quote(state);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  var done = false;
  while (!done) {
    if (can_parse(parse_quote(state))) {
      done = true;
    } else {
      res = parse_json_string_char(state);
      if (!can_parse(res)) {
        return fail_parse(input);
      }
      ignore_str(must_parse_str(res));
    }
  }

  ignore_str(must_parse_str(parse_quote(state)));

  var out = int_vector_new();
  for (var i = input.pos + 1; i < state.pos - 1; i = i + 1;) {
    out = int_vector_append(out, input.str[i]);
  }
  return new ParseResult {
    input = input;
    node = wrap_str(new JsonString {
      str = string_of_array(array_of_int_vector(out))
    });
    str = string null;
    count = state.pos - input.pos
  };
}

/* parse_json_integer is a helper for parse_json_number */
ParseResult parse_json_integer(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_this(state, "-");
  var negative = can_parse(res);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }
  
  res = parse_matching_char(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  if (str_eq(must_parse_str(res), "0")) {
    return parse_result_of_difference(input, state);
  }

  state.pos = state.pos - 1;
  ignore_str(must_parse_str(parse_matching_chars(state, is_valid_digit_char)));

  return parse_result_of_difference(input, state);
}

/* parse_json_fraction is a helper for parse_json_number */
ParseResult parse_json_fraction(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_this(state, ".");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_chars(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  return parse_result_of_difference(input, state);
}

/* parse_json_exponent is a helper for parse_json_number */
ParseResult parse_json_exponent(ParseState input) { 
  var state = copy_parse_state(input);

  var res = parse_matching_char(state, is_valid_exponent_e_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  res = parse_matching_char(state, is_valid_exponent_sign_char);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }

  res = parse_matching_chars(state, is_valid_digit_char);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  return parse_result_of_difference(input, state);
}

/*
parse_json_number reads a JSON number. The output is a string which contains
exactly the same characters as the JSON file did. The number is not evaluated
to an Oat int.
*/
ParseResult parse_json_number(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_json_integer(state);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  res = parse_json_fraction(state);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }

  res = parse_json_exponent(state);
  if (can_parse(res)) {
    ignore_str(must_parse_str(res));
  }

  var output = parse_result_of_difference(input, state);
  if? (string str = output.str) {
    output.node = wrap_number(new JsonNumber { number = str });
  } else {
    assert(false);
  }
  output.str = string null;
  return output;
}

/* parse_json_boolean reads a JSON boolean literal. */
ParseResult parse_json_boolean(ParseState input) {
  var res = parse_this(input, "true");
  if (can_parse(res)) {
    return new ParseResult {
      input = input;
      node = wrap_boolean(new JsonBoolean { boolean = true });
      str = string null;
      count = 4
    };
  }

  res = parse_this(input, "false");
  if (can_parse(res)) {
    return new ParseResult {
      input = input;
      node = wrap_boolean(new JsonBoolean { boolean = false });
      str = string null;
      count = 5
    };
  }

  return fail_parse(input);
}

/* parse_json_null reads a JSON null literal. */
ParseResult parse_json_null(ParseState input) {
  var res = parse_this(input, "null");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  return new ParseResult {
    input = input;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 4
  };
}

/* parse_json_array parses a JSON array. */
ParseResult parse_json_array(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_this(state, "[");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  try_parse(state, parse_whitespace);

  var pre_elem_state = copy_parse_state(state);
  var elem_count = 0;
  var done = false;
  var should_finish = false;
  while (!done) {
    res = parse_whitespace_surrounded(state, parse_json_value);

    if (elem_count > 0) {
      if ((can_parse(res) & should_finish) | (!can_parse(res) & !should_finish)) {
        return fail_parse(input);
      }
    }
    if (can_parse(res)) {
      ignore_node(must_parse_node(res));
      elem_count = elem_count + 1;

      res = parse_this(state, ",");
      if (can_parse(res)) {
        ignore_str(must_parse_str(res));
      }
      should_finish = !can_parse(res);
    } else {
      done = true;
    }
  }

  state = pre_elem_state;
  var elems = new Json[elem_count]{i -> empty_json};
  for (var i = 0; i < elem_count; i = i + 1;) {
    if (i != 0) {
      ignore_str(must_parse_str(parse_this(state, ",")));
    }
    elems[i] = must_parse_node(parse_whitespace_surrounded(state, parse_json_value));
  }

  res = parse_this(state, "]");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  var output = parse_result_of_difference(input, state);
  output.str = string null;
  output.node = wrap_arr(new JsonArray { arr = elems });
  return output;
}

/* parse_json_object parses a JSON object (without surrounding whitespace). */
ParseResult parse_json_object(ParseState input) {
  var state = copy_parse_state(input);

  var res = parse_this(state, "{");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  try_parse(state, parse_whitespace);

  var pre_elem_state = copy_parse_state(state);
  var elem_count = 0;
  var done = false;
  var should_finish = false;
  while (!done) {
    res = parse_whitespace_surrounded(state, parse_json_string);

    if (elem_count > 0) {
      if ((can_parse(res) & should_finish) | (!can_parse(res) & !should_finish)) {
        return fail_parse(input);
      }
    }
    if (can_parse(res)) {
      ignore_node(must_parse_node(res));
      elem_count = elem_count + 1;

      res = parse_this(state, ":");
      if (!can_parse(res)) {
        return fail_parse(input);
      }
      ignore_str(must_parse_str(res));

      res = parse_whitespace_surrounded(state, parse_json_value);
      if (!can_parse(res)) {
        return fail_parse(input);
      }
      ignore_node(must_parse_node(res));

      res = parse_this(state, ",");
      if (can_parse(res)) {
        ignore_str(must_parse_str(res));
      }
      should_finish = !can_parse(res);
    } else {
      done = true;
    }
  }

  state = pre_elem_state;
  var elems = new JsonMember[elem_count]{i -> new JsonMember { str = ""; element = empty_json }};
  for (var i = 0; i < elem_count; i = i + 1;) {
    if (i != 0) {
      ignore_str(must_parse_str(parse_this(state, ",")));
    }

    var key_node = must_parse_node(parse_whitespace_surrounded(state, parse_json_string));
    ignore_str(must_parse_str(parse_this(state, ":")));
    var value_node = must_parse_node(parse_whitespace_surrounded(state, parse_json_value));

    var key = "";
    if? (JsonString str = key_node.str) {
      key = str.str;
    } else {
      assert(false);
    }

    elems[i] = new JsonMember { str = key; element = value_node };
  }

  res = parse_this(state, "}");
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  ignore_str(must_parse_str(res));

  var output = parse_result_of_difference(input, state);
  output.str = string null;
  output.node = wrap_obj(new JsonObject { members = elems });
  return output;
}

/* parse_json_value parses any JSON value, but does not accept whitespace around it. */
ParseResult parse_json_value(ParseState input) {
  var results = new ParseResult[]{
    parse_json_object(input),
    parse_json_array(input),
    parse_json_string(input),
    parse_json_number(input),
    parse_json_boolean(input),
    parse_json_null(input)
  };
  for (var i = 0; i < length(results); i = i + 1;) {
    var res = results[i];
    if (can_parse(res)) {
      return res;
    }
  }
  return fail_parse(input);
}

/* parse_whitespace_surrounded runs a parser, and consumes leading and trailing whitespace. */
ParseResult parse_whitespace_surrounded(ParseState input, (ParseState) -> ParseResult f) {
  var state = copy_parse_state(input);

  try_parse(state, parse_whitespace);

  var res = f(state);
  if (!can_parse(res)) {
    return fail_parse(input);
  }
  state.pos = state.pos + res.count;

  try_parse(state, parse_whitespace);

  res.input = input;
  res.count = state.pos - input.pos;
  return res;
}

/*
parse_json converts a string to JSON AST. It allows surrounding whitespace,
but fails on other leading or trailing characters. This function fails using assert().
*/
Json parse_json(string input) {
  var state = parse_state_of_string(input);
  var res = parse_whitespace_surrounded(state, parse_json_value);
  var output = must_parse_node(res);
  assert(state.pos == length_of_string(input));
  return output;
}

void assert_parse_string(ParseResult result, string expected) {
  assert(str_eq(must_parse_str(copy_parse_result(result)), expected));
  return;
}

void test_must_parse_str() {
  var state = parse_state_of_string("walrus");
  assert(length(state.str) == 6);
  assert(state.pos == 0);

  /* Case: Typical parse */
  var output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  });
  assert(str_eq(output, "wal"));
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "r";
    count = 1
  });
  assert(str_eq(output, "r"));
  assert(state.pos == 4);

  /* Case: Count does not match string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 2
  });
  assert(did_assert());

  /* Case: Null string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Empty string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  });
  assert(did_assert());

  /* Case: Also contains JSON node */
  await_assert();
  output = must_parse_str(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wal";
    count = 3
  });
  assert(did_assert());

  return;
}

void test_must_parse_node() {
  /* Case: Typical */
  var state = parse_state_of_string("walrus");
  var output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  });
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 1
  });
  assert(state.pos == 4);

  /* Case: Null node */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Also contains string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wa";
    count = 2
  });
  assert(did_assert());

  return;
}

void test_can_parse() {
  var state = parse_state_of_string("walrus");

  /* Case: Typical node */
  assert(can_parse(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  }));

  /* Case: Typical string */
  assert(can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  }));

  /* Case: Empty string */
  assert(!can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  }));

  /* Case: Totally empty */
  assert(!can_parse(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 0
  }));

  return;
}

void test_parse_this() {
  var state = parse_state_of_string("say walrus please");
  var output = must_parse_str(parse_this(state, "say w"));
  assert(str_eq(output, "say w"));
  assert(can_parse(parse_this(state, "alrus")));
  assert(!can_parse(parse_this(state, "walrus")));

  state = parse_state_of_string("say walrus please");
  assert_parse_string(parse_this(state, "say walrus please"), "say walrus please");
  assert_parse_string(parse_this(state, "say w"), "say w");
  assert_parse_string(parse_this(state, "s"), "s");
  assert(!can_parse(parse_this(state, "say walrus please ")));
  assert(!can_parse(parse_this(state, " say w")));
  assert(!can_parse(parse_this(state, "x")));

  return;
}

void test_parse_quote() {
  var state = parse_state_of_string(convert_quotes("Such '''testing''', right?"));
  assert(!can_parse(parse_quote(state)));
  ignore_str(must_parse_str(parse_this(state, "Such")));
  assert(!can_parse(parse_quote(state)));
  ignore_str(must_parse_str(parse_this(state, " ")));
  assert_parse_string(parse_quote(state), convert_quotes("'"));
  ignore_str(must_parse_str(parse_quote(state)));
  ignore_str(must_parse_str(parse_quote(state)));
  ignore_str(must_parse_str(parse_quote(state)));
  assert(!can_parse(parse_quote(state)));
  return;
}

void test_parse_whitespace() {
  var state = parse_state_of_string("   say
  
  
   walrus
please

");
  assert(str_eq(must_parse_str(parse_whitespace(state)), "   "));
  ignore_str(must_parse_str(parse_this(state, "say")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  ignore_str(must_parse_str(parse_this(state, "walrus")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  ignore_str(must_parse_str(parse_this(state, "please")));
  ignore_str(must_parse_str(parse_whitespace(state)));
  assert(!can_parse(parse_whitespace(state)));
  return;
}

void test_parse_json_string() {
  var state = parse_state_of_string(convert_quotes("'walrus'"));
  var output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, "walrus"));
  } else {
    assert(false);
  }

  /*
  TODO Possible compiler bug: The folowing commented section does not work, but the
  uncommented one below it does. I think both piecs of code should behave the same way.
  */
  /* state = parse_state_of_string(convert_slashes(convert_quotes("'/n/n///txyz/''abc")));
  if? (string str = must_parse_node(parse_json_string(state)).str) {
    assert(str_eq(str.str, convert_slashes(convert_quotes("/n/n///txyz/'"))));
  } else {
    assert(false);
  } */

  state = parse_state_of_string(convert_slashes(convert_quotes("'/n/n///txyz/''abc")));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, convert_slashes(convert_quotes("/n/n///txyz/'"))));
  } else {
    assert(false);
  }

  state = parse_state_of_string(convert_slashes(convert_quotes("'/u1234/uABCD/uefAB/u0000'")));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, convert_slashes("/u1234/uABCD/uefAB/u0000")));
  } else {
    assert(false);
  }

  state = parse_state_of_string(convert_slashes(convert_quotes("'/u1234/uABCG/uefAB/u0000'")));
  assert(!can_parse(parse_json_string(state)));

  state = parse_state_of_string(convert_quotes("''"));
  output = must_parse_node(parse_json_string(state));
  if? (string str = output.str) {
    assert(str_eq(str.str, ""));
  } else {
    assert(false);
  }

  return;
}

void test_parse_json_integer() {
  assert_parse_string(parse_json_integer(parse_state_of_string("123")), "123");
  assert_parse_string(parse_json_integer(parse_state_of_string("-123")), "-123");
  assert_parse_string(parse_json_integer(parse_state_of_string("0123")), "0");
  assert_parse_string(parse_json_integer(parse_state_of_string("-0123")), "-0");
  assert_parse_string(parse_json_integer(parse_state_of_string("-0123")), "-0");
  assert_parse_string(parse_json_integer(parse_state_of_string("0")), "0");
  assert_parse_string(parse_json_integer(parse_state_of_string("9")), "9");
  assert(!can_parse(parse_json_integer(parse_state_of_string(" 9"))));
  assert(!can_parse(parse_json_integer(parse_state_of_string("a9"))));
  assert(!can_parse(parse_json_integer(parse_state_of_string(".9"))));
  return;
}

void test_parse_json_fraction() {
  assert_parse_string(parse_json_fraction(parse_state_of_string(".123")), ".123");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".000")), ".000");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".0")), ".0");
  assert_parse_string(parse_json_fraction(parse_state_of_string(".9")), ".9");
  assert(!can_parse(parse_json_integer(parse_state_of_string("."))));
  assert(!can_parse(parse_json_integer(parse_state_of_string("..123"))));
  assert_parse_string(parse_json_fraction(parse_state_of_string(".1.2.3")), ".1");
  return;
}

void test_parse_json_exponent() {
  assert_parse_string(parse_json_exponent(parse_state_of_string("e12")), "e12");
  assert_parse_string(parse_json_exponent(parse_state_of_string("e0000")), "e0000");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E1")), "E1");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E+12")), "E+12");
  assert_parse_string(parse_json_exponent(parse_state_of_string("E-11")), "E-11");
  assert(!can_parse(parse_json_exponent(parse_state_of_string("12"))));
  assert(!can_parse(parse_json_exponent(parse_state_of_string("o12"))));
  assert(!can_parse(parse_json_exponent(parse_state_of_string("-12"))));
  return;
}

void assert_parse_json_number(string input, string expected) {
  var actual = must_parse_node(parse_json_number(parse_state_of_string(input)));
  if? (JsonNumber number = actual.number) {
    assert(str_eq(number.number, expected));
  } else {
    assert(false);
  }
  return;
}

void test_parse_json_number() {
  assert_parse_json_number("123", "123");
  assert_parse_json_number("123.456", "123.456");
  assert_parse_json_number("-123.456e+78", "-123.456e+78");
  assert(!can_parse(parse_json_number(parse_state_of_string(" 123"))));
  assert_parse_json_number("-123:456e+78", "-123");
  assert_parse_json_number("-123.456q+78", "-123.456");
  assert_parse_json_number("-123.456e+", "-123.456");
  return;
}

void test_parse_json_boolean() {
  var output = must_parse_node(parse_json_boolean(parse_state_of_string("true")));
  if? (JsonBoolean boolean = output.boolean) {
    assert(boolean.boolean);
  } else {
    assert(false);
  }

  output = must_parse_node(parse_json_boolean(parse_state_of_string("false")));
  if? (JsonBoolean boolean = output.boolean) {
    assert(!(boolean.boolean));
  } else {
    assert(false);
  }

  assert(!can_parse(parse_json_boolean(parse_state_of_string("True"))));
  assert(!can_parse(parse_json_boolean(parse_state_of_string("False"))));
  assert(!can_parse(parse_json_boolean(parse_state_of_string(" true"))));
  assert(!can_parse(parse_json_boolean(parse_state_of_string(" false"))));

  return;
}

void test_parse_json_null() {
  var output = must_parse_node(parse_json_null(parse_state_of_string("null")));
  if? (JsonNull nil = output.nil) {
    /* intentionally empty */
  } else {
    assert(false);
  }

  assert(!can_parse(parse_json_null(parse_state_of_string("Null"))));
  assert(!can_parse(parse_json_null(parse_state_of_string(" null"))));
  assert(!can_parse(parse_json_null(parse_state_of_string("nil"))));
  assert(!can_parse(parse_json_null(parse_state_of_string("undefined"))));

  return;
}

void test_parse_json_array() {
  var input = convert_quotes("['test', 123.45, true, [123, null], []]");
  var output = must_parse_node(parse_json_array(parse_state_of_string(input)));
  if? (JsonArray arr = output.arr) {
    assert(length(arr.arr) == 5);
    if? (JsonString str = arr.arr[0].str) {
      assert(str_eq(str.str, "test"));
    } else {
      assert(false);
    }
    if? (JsonArray inner_arr = arr.arr[3].arr) {
      assert(length(inner_arr.arr) == 2);
    } else {
      assert(false);
    }
    if? (JsonArray inner_arr = arr.arr[4].arr) {
      assert(length(inner_arr.arr) == 0);
    } else {
      assert(false);
    }
  } else {
    assert(false);
  }

  assert(can_parse(parse_json_array(parse_state_of_string("[]"))));
  assert(can_parse(parse_json_array(parse_state_of_string("[123]"))));
  assert(!can_parse(parse_json_array(parse_state_of_string("[123,]"))));
  assert(!can_parse(parse_json_array(parse_state_of_string("[,]"))));

  return;
}

void test_parse_json_object() {
  var input = convert_quotes("{'bestAnimal': {'type': 'walrus', 'weight_kg': 1500, 'features': ['tusks', 'moustache']}}");
  var output = must_parse_node(parse_json_object(parse_state_of_string(input)));
  if? (JsonObj obj = output.obj) {
    assert(length(obj.members) == 1);
    assert(str_eq(obj.members[0].str, "bestAnimal"));
    if? (JsonObj inner_obj = obj.members[0].element.obj) {
      assert(length(inner_obj.members) == 3);
      assert(str_eq(inner_obj.members[0].str, "type"));
      assert(str_eq(inner_obj.members[2].str, "features"));
    } else {
      assert(false);
    }
  } else {
    assert(false);
  }

  assert(can_parse(parse_json_object(parse_state_of_string("{}"))));
  assert(!can_parse(parse_json_object(parse_state_of_string(convert_quotes("{'test'}")))));
  assert(!can_parse(parse_json_object(parse_state_of_string(convert_quotes("{'test': }")))));
  assert(can_parse(parse_json_object(parse_state_of_string(convert_quotes("{'test': 123}")))));
  assert(can_parse(parse_json_object(parse_state_of_string(convert_quotes("{'':123}")))));
  assert(can_parse(parse_json_object(parse_state_of_string(convert_quotes("{  ''  :  123   }")))));
  assert(!can_parse(parse_json_object(parse_state_of_string("{,}"))));

  return;
}

void test_parse_json_value() {
  var good_inputs = new string[]{
    "123",
    "123.456e+12",
    "true",
    "false",
    "null",
    "'test'",
    "''",
    "[]",
    "[123, 45,    'test']",
    "[123,45,'test']",
    "{}"
  };
  for (var i = 0; i < length(good_inputs); i = i + 1;) {
    var res = parse_json_value(parse_state_of_string(convert_quotes(good_inputs[i])));
    ignore_node(must_parse_node(res));
    assert(length_of_string(good_inputs[i]) == res.count);
  }

  var bad_inputs = new string[]{
    " 123",
    "123 ",
    "123ee5",
    "true ",
    " null",
    "'test''test'",
    "'test''",
    " []",
    " [123,45,'test']",
    "[123,45,'test'] ",
    " {}"
  };
  for (var i = 0; i < length(bad_inputs); i = i + 1;) {
    var res = parse_json_value(parse_state_of_string(convert_quotes(bad_inputs[i])));
    assert(length_of_string(bad_inputs[i]) != res.count);
  }

  return;
}

void test_parse_whitespace_surrounded() {
  var good_inputs = new string[]{
    "true",
    "    true    ",
    "    false    ",
    "true ",
    " true"
  };

  for (var i = 0; i < length(good_inputs); i = i + 1;) {
    var res = parse_whitespace_surrounded(parse_state_of_string(good_inputs[i]), parse_json_boolean);
    ignore_node(must_parse_node(res));
    assert(length_of_string(good_inputs[i]) == res.count);
  }

  var bad_inputs = new string[]{
    "rue",
    "    rue    ",
    "    alse    ",
    "    falsefalse    ",
    "    falsefalse    ",
    "tr  ",
    " rue"
  };
  for (var i = 0; i < length(bad_inputs); i = i + 1;) {
    var res = parse_whitespace_surrounded(parse_state_of_string(bad_inputs[i]), parse_json_boolean);
    assert(length_of_string(bad_inputs[i]) != res.count);
  }

  return;
}

void test_parse_json() {
  var good_inputs = new string[]{
    "[123.456e-789]"
  };
  for (var i = 0; i < length(good_inputs); i = i + 1;) {
    ignore_node(parse_json(good_inputs[i]));
  }

  var bad_inputs = new string[]{
    convert_quotes("['x']]")
  };
  for (var i = 0; i < length(bad_inputs); i = i + 1;) {
    await_assert();
    ignore_node(parse_json(bad_inputs[i]));
    assert(did_assert());
  }

  return;
}

void test_parser(){
  test_must_parse_str();
  test_must_parse_node();
  test_can_parse();
  test_parse_this();
  test_parse_quote();
  test_parse_whitespace();
  test_parse_json_string();
  test_parse_json_integer();
  test_parse_json_fraction();
  test_parse_json_exponent();
  test_parse_json_number();
  test_parse_json_boolean();
  test_parse_json_null();
  test_parse_json_array();
  test_parse_json_object();
  test_parse_json_value();
  test_parse_whitespace_surrounded();
  test_parse_json();

  if (assert_disabled_for_test) {
    /* await_assert() without matching did_assert() */
    assert_disabled_for_test = false;
    assert(false);
  }
  return;
}

/************ END PARSER ************/

/*********** BEGIN VECTOR ***********/

struct IntVector {
  int[] data;
  int len;
  int capacity
}

IntVector int_vector_new() {
  var initialCapacity = 8;
  return new IntVector {
    data = new int[initialCapacity]{i -> 0};
    len = 0;
    capacity = initialCapacity
  };
}

int int_vector_get(IntVector vector, int index, int default) {
  if (index < 0 | index >= vector.len) {
    return default;
  }
  return vector.data[index];
}

IntVector int_vector_append(IntVector inVector, int value) {
  var outVector = inVector;
  if (inVector.len + 1 >= inVector.capacity) {
    var outCapacity = inVector.capacity * 2;
    outVector = new IntVector {
      data = new int[outCapacity]{i -> int_vector_get(inVector, i, 0)};
      len = inVector.len;
      capacity = outCapacity
    };
  }
  outVector.data[outVector.len] = value;
  outVector.len = outVector.len + 1;
  return outVector;
}

int[] array_of_int_vector(IntVector vector) {
  return new int[vector.len]{i -> vector.data[i]};
}

void test_vector() {
  var vec = int_vector_new();
  assert(vec.len == 0);
  vec = int_vector_append(vec, 1);
  vec = int_vector_append(vec, 8);
  vec = int_vector_append(vec, 3);
  assert(vec.len == 3);
  assert(vec.data[0] == 1);
  assert(vec.data[1] == 8);
  assert(vec.data[2] == 3);
  for (var i = 0; i < 100; i = i + 1;) {
    vec = int_vector_append(vec, 7);
  }
  assert(vec.len == 103);
  assert(vec.data[102] == 7);
  return;
}

/************ END VECTOR ************/

/*********** BEGIN PRINTER ***********/
global indent_size = "  ";

string convert_quotes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_single_quote) {
      chars[i] = char_double_quote;
    }
  }
  return string_of_array(chars);
}

string convert_slashes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_forward_slash) {
      chars[i] = char_backslash;
    }
  }
  return string_of_array(chars);
}

string print_indent(int depth){
  var indent = "";
  for(var i=0;i<depth;i=i+1;){
    indent = string_cat(indent, indent_size);
  }
  return indent;
}

string print_member(JsonMember tmp, int depth){
  var s = "'";
  s = string_cat(s, tmp.str);
  s = string_cat(s, "': ");
  s = string_cat(s, print_json(tmp.element, depth));
  return convert_quotes(s);
}

string print_obj(JsonObject tmp, int depth){
  var s = "{\n";
  for(var i=0;i<length(tmp.members);i=i+1;){
    s = string_cat(s, print_indent(depth));
    s = string_cat(s, print_member(tmp.members[i], depth+1));
    if (i<length(tmp.members)-1){
      s = string_cat(s, ",");
    }
    s = string_cat(s, "\n");
  } 
  s = string_cat(s, print_indent(depth-1));
  s = string_cat(s, "}");
  return s;
}

string print_array(JsonArray tmp, int depth){
  var s = "[\n";
  for(var i=0;i<length(tmp.arr);i=i+1;){
    s = string_cat(s, print_indent(depth));
    s = string_cat(s, print_json(tmp.arr[i], depth+1));
    if (i<length(tmp.arr)-1){
      s = string_cat(s, ",");
    }
    s = string_cat(s, "\n");
  }
  s = string_cat(s, print_indent(depth-1));
  s = string_cat(s, "]");
  return s;
}

string print_str(JsonString tmp){
  var s = "'";
  s = string_cat(s, tmp.str);
  s = string_cat(s, "'");
  return convert_quotes(s);
}

string print_number(JsonNumber tmp){
  return tmp.number;
}

string print_boolean(JsonBoolean tmp){
  if (tmp.boolean){
    return "true";
  }
  return "false";
}

string print_null(JsonNull tmp){
  return "null";
}

string print_json(Json? tmp, int depth){
  var s = "this string should be overwritten\n";
  if? (Json j = tmp){
    if? (JsonObject obj = j.obj){
      s = print_obj(obj, depth);
    }
    if? (JsonArray arr = j.arr){
      s = print_array(arr, depth);
    }
    if? (JsonString str = j.str){
      s = print_str(str);
    }
    if? (JsonNumber number = j.number){
      s = print_number(number);
    } 
    if? (JsonBoolean boolean = j.boolean){
      s = print_boolean(boolean);
    }
    if? (JsonNull nil = j.nil){
      s = print_null(nil);
    }
    if (debug){
      print_string(string_cat(s, "\n"));
    }
  }
  return s; 
}

Json wrap_obj(JsonObject obj){
  return new Json {
    obj = obj;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_arr(JsonArray arr){
  return new Json {
    obj = JsonObject null;
    arr = arr;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_str(JsonString str){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = str;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_number(JsonNumber number){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = number;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_boolean(JsonBoolean boolean){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = boolean;
    nil = JsonNull null
  };
}

Json wrap_nil(JsonNull nil){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = nil
  };
}

void test_mixed(){
  var test1 = print_json(wrap_obj(
    new JsonObject{
      members = new JsonMember[]{
        new JsonMember{str = "id"; element = wrap_str(new JsonString {str = "file"})},
        new JsonMember{str = "value"; element = wrap_str(new JsonString {str = "File"})},
        new JsonMember{str = "popup"; element = wrap_obj(
          new JsonObject{
            members = new JsonMember[]{
              new JsonMember{str = "menuitem"; element = wrap_arr(
                new JsonArray {
                  arr = new Json[]{
                    wrap_obj(new JsonObject{
                      members = new JsonMember[]{
                        new JsonMember{str = "value"; element = wrap_str(new JsonString {str = "New"})},
                        new JsonMember{str = "onclick"; element = wrap_str(new JsonString {str = "CreateNewDoc()"})}
                      }
                    }),
                    wrap_obj(new JsonObject{
                      members = new JsonMember[]{
                        new JsonMember{str = "value"; element = wrap_str(new JsonString {str = "Open"})},
                        new JsonMember{str = "onclick"; element = wrap_str(new JsonString {str = "OpenDoc()"})}
                      }
                    }),
                    wrap_obj(new JsonObject{
                      members = new JsonMember[]{
                        new JsonMember{str = "value"; element = wrap_str(new JsonString {str = "Close"})},
                        new JsonMember{str = "onclick"; element = wrap_str(new JsonString {str = "CloseDoc()"})}
                      }
                    })
                  }
                }
              )}
            }
          }
        )},
        new JsonMember{str = "amazing"; element = wrap_boolean(new JsonBoolean {boolean = true})},
        new JsonMember{str = "rating"; element = wrap_number(new JsonNumber {number = "10"})},
        new JsonMember{str = "fake"; element = wrap_nil(new JsonNull {})}
      }
    }
  ), 1);

  var ref1 =convert_quotes( 
"{
  'id': 'file',
  'value': 'File',
  'popup': {
    'menuitem': [
      {
        'value': 'New',
        'onclick': 'CreateNewDoc()'
      },
      {
        'value': 'Open',
        'onclick': 'OpenDoc()'
      },
      {
        'value': 'Close',
        'onclick': 'CloseDoc()'
      }
    ]
  },
  'amazing': true,
  'rating': 10,
  'fake': null
}");

  assert(str_eq(test1, ref1)); 
  return;
}

void test_obj(){
  var test1 = print_json(wrap_obj(
      new JsonObject{
        members = new JsonMember[]{
          new JsonMember{str = "hallo"; element = wrap_number(new JsonNumber {number = "3"})}
        }
      }
    ), 1);

  var ref1 = convert_quotes(
"{
  'hallo': 3
}");

  assert(str_eq(test1, ref1));

  var test2 = print_json(wrap_obj(
      new JsonObject {
        members = new JsonMember[]{
          new JsonMember{
            str = "Team"; 
            element = wrap_obj(new JsonObject{
              members = new JsonMember[]{
                new JsonMember{str = "#1"; element = wrap_str(new JsonString {str = "Flo"})},
                new JsonMember{str = "#2"; element = wrap_str(new JsonString {str = "Philippe"})}
              }
            }) 
          },
          new JsonMember{
            str = "Animals"; 
            element = wrap_obj(new JsonObject{
              members = new JsonMember[]{
                new JsonMember{str = "#1"; element = wrap_str(new JsonString {str = "Panda"})},
                new JsonMember{str = "#2"; element = wrap_str(new JsonString {str = "Walrus"})}
              }
            }) 
          }
        }
      }
    ), 1);

  var ref2 = convert_quotes(
"{
  'Team': {
    '#1': 'Flo',
    '#2': 'Philippe'
  },
  'Animals': {
    '#1': 'Panda',
    '#2': 'Walrus'
  }
}");

  assert(str_eq(test2, ref2)); 

  return;
}

void test_arr(){
  assert(str_eq(
    print_json(wrap_arr(
      new JsonArray {
        arr = new Json[]{
          wrap_number(new JsonNumber {number = "0"}),
          wrap_number(new JsonNumber {number = "0"}),
          wrap_number(new JsonNumber {number = "0"})
         }
      }
    ), 1), 
"[
  0,
  0,
  0
]"
  ));
  assert(str_eq(
    print_json(wrap_arr(
      new JsonArray {
        arr = new Json[]{
          wrap_number(new JsonNumber {number = "0"}),
          wrap_boolean(new JsonBoolean {boolean = true}),
          wrap_boolean(new JsonBoolean {boolean = false}),
          wrap_nil(new JsonNull {})
         }
      }
    ), 1), 
"[
  0,
  true,
  false,
  null
]"
  ));

  return;
}

void test_str(){
  assert(str_eq(
    print_json(wrap_str(
      new JsonString {
        str = "flooo"
      }
    ), 1),
    convert_quotes("'flooo'")
  ));
  assert(str_eq(
    print_json(wrap_str(
      new JsonString {
        str = "walrus"
      }
    ), 1),
    convert_quotes("'walrus'")
  ));

  return;
}

void test_number(){
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "0"}), 0), "0"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "1"}), 0), "1"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "2"}), 0), "2"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "3"}), 0), "3"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "4"}), 0), "4"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "5"}), 0), "5"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "6"}), 0), "6"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "7"}), 0), "7"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "8"}), 0), "8"
  ));
  assert(str_eq(
    print_json(wrap_number(new JsonNumber {number = "9"}), 0), "9"
  ));
  return;
}

void test_boolean(){
  assert(str_eq(
    print_json(wrap_boolean(new JsonBoolean {boolean = true}), 0), "true"
  ));
   assert(str_eq(
    print_json(wrap_boolean(new JsonBoolean {boolean = false}), 0), "false"
  ));
  return;
}

void test_null(){
  assert(str_eq(
    print_json(wrap_nil(new JsonNull {}), 0), "null"
  ));
  return;
}

void test_printer() {
  test_null();
  test_boolean();
  test_number();
  test_str();
  test_arr();
  test_obj();
  test_mixed();
  return;
}

/************ END PRINTER ************/

void test_parser_printer(){
  var input = convert_quotes("{'id':'file','value': 'File','popup': {'menuitem': [{'value': 'New', 'onclick': 'CreateNewDoc()' }, { 'value': 'Open', 'onclick': 'OpenDoc()' }, { 'value': 'Close', 'onclick': 'CloseDoc()' } ] }, 'amazing': true, 'rating': 10, 'fake': null }");
  /* {\"id\":\"file\",\"value\": \"File\",\"popup\": {\"menuitem\": [{\"value\": \"New\", \"onclick\": \"CreateNewDoc()\" }, { \"value\": \"Open\", \"onclick\": \"OpenDoc()\" }, { \"value\": \"Close\", \"onclick\": \"CloseDoc()\" } ] }, \"amazing\": true, \"rating\": 10, \"fake\": null } */
  var state = parse_state_of_string(input);
  var res = parse_whitespace_surrounded(state, parse_json_value);
  var output_parser = must_parse_node(res);

  var output_printer = print_json(output_parser, 1);

  var expected = convert_quotes( 
"{
  'id': 'file',
  'value': 'File',
  'popup': {
    'menuitem': [
      {
        'value': 'New',
        'onclick': 'CreateNewDoc()'
      },
      {
        'value': 'Open',
        'onclick': 'OpenDoc()'
      },
      {
        'value': 'Close',
        'onclick': 'CloseDoc()'
      }
    ]
  },
  'amazing': true,
  'rating': 10,
  'fake': null
}");

  assert(str_eq(output_printer, expected)); 
  return;
}

int program(int argc, string[] argv) {
  test_printer(); 
  test_parser();
  test_vector();
  test_parser_printer();
  print_string("PASSED");

  return 0;
}