/*
json
  element

element
  object
  array
  string
  number
  "true"
  "false"
  "null"

object
  '{' members '}'

members
  member
  member ',' members

member
  string ':' element

array
  '[' elements ']'

elements
  element
  element ',' elements

*/

struct Json {
  JsonObject? obj;
  JsonArray? arr;
  JsonString? str;
  JsonNumber? number;
  JsonBoolean? boolean;
  JsonNull? nil
}

struct JsonObject{
  JsonMember[] members
}

struct JsonMember {
  string str;
  Json element
}

struct JsonArray{
  Json[] element
}

struct JsonString{
  string str
}

struct JsonNumber{
  int number
}

struct JsonBoolean{
  bool boolean
}

struct JsonNull {
}

global char_tab = 9;
global char_lf = 10;
global char_cr = 13;
global char_space = 32;
global char_double_quote = 34;
global char_hash = 35;
global char_single_quote = 39;
global char_zero = 48;
global char_upper_a = 65;
global char_lower_a = 97;

global empty_json = new Json {
  obj = JsonObject null;
  arr = JsonArray null;
  str = JsonString null;
  number = JsonNumber null;
  boolean = JsonBoolean null;
  nil = JsonNull null
};

/*********** BEGIN PARSER ***********/

/* ParseResult is returned from every parser */
struct ParseResult {
  ParseState input;
  Json? node;
  string? str;
  int count
}

/* ParseState is the input to every parser */
struct ParseState {
  int[] str;
  int pos
}

ParseState parse_state_of_string(string s) {
  return new ParseState { str = array_of_string(s); pos = 0 };
}

/*
must_parse_str asserts that the given ParseResult contains a string 
and advances the ParseState. It returns the string from the ParseResult.
*/
string must_parse_str(ParseResult res) {
  /* TODO if? else if? is broken in our compiler */
  if? (Json node = res.node) {
    assert(false);
    return "";
  }
  if? (string str = res.str) {
    assert(length_of_string(str) == res.count);
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return str;
  }
  assert(false);
  return "";
}

/*
must_parse_node asserts that the given ParseResult contains a JSON node
and advances the ParseState. It returns the Json struct from the ParseResult.
*/
Json must_parse_node(ParseResult res) {
  if? (string str = res.str) {
    assert(false);
    return empty_json;
  }
  if? (Json node = res.node) {
    assert(res.count > 0);
    res.input.pos = res.input.pos + res.count;
    return node;
  }
  assert(false);
  return empty_json;
}

/*
can_parse_some checks whether the given ParseResult would consume any
characters if applied with must_parse_string or must_parse_node.
*/
bool can_parse_some(ParseResult res) {
  return res.count > 0;
}


/************ END PARSER ************/

/*********** BEGIN VECTOR ***********/

struct IntVector {
  int[] data;
  int len;
  int capacity
}

IntVector int_vector_new() {
  var initialCapacity = 8;
  return new IntVector {
    data = new int[initialCapacity]{i -> 0};
    len = 0;
    capacity = initialCapacity
  };
}

int int_vector_get(IntVector vector, int index, int default) {
  if (index < 0 | index >= vector.len) {
    return default;
  }
  return vector.data[index];
}

IntVector int_vector_append(IntVector inVector, int value) {
  var outVector = inVector;
  if (inVector.len + 1 >= inVector.capacity) {
    var outCapacity = inVector.capacity * 2;
    outVector = new IntVector {
      data = new int[outCapacity]{i -> int_vector_get(inVector, i, 0)};
      len = inVector.len;
      capacity = outCapacity
    };
  }
  outVector.data[outVector.len] = value;
  outVector.len = outVector.len + 1;
  return outVector;
}

/************ END VECTOR ************/

string convert_quotes(string s) {
  var len = length_of_string(s);
  var chars = array_of_string(s);
  for (var i = 0; i < len; i = i + 1;) {
    if (chars[i] == char_single_quote) {
      chars[i] = char_double_quote;
    }
  }
  return string_of_array(chars);
}

void print_obj(JsonObject tmp){
  return;
}

void print_array(JsonArray tmp){
  return;
}

void print_str(JsonString tmp){
  return;
}

void print_number(JsonNumber tmp){
  print_int(tmp.number);
  return;
}

void print_boolean(JsonBoolean tmp){
  print_bool(tmp.boolean);
  return;
}

string print_null(JsonNull tmp){
  return "null";
}

string print_json(Json? tmp){
  if? (Json j = tmp){
    if? (JsonObject obj = j.obj){
      print_obj(obj);
    }
    if? (JsonArray arr = j.arr){
      print_array(arr);
    }
    if? (JsonString str = j.str){
      print_str(str);
    }
    if? (JsonNumber number = j.number){
      print_number(number);
    } 
    if? (JsonBoolean boolean = j.boolean){
      print_boolean(boolean);
    }
    if? (JsonNull nil = j.nil){
      return print_null(nil);
    }
  }
  return "TODO"; 
}

global assert_disabled_for_test = false;
global would_fail_assert = false;

void await_assert() {
  if (assert_disabled_for_test) {
    print_string("already waiting for assert\n");
    assert_disabled_for_test = false;
    assert(false);
    return;
  }
  assert_disabled_for_test = true;
  would_fail_assert = false;
  return;
}

bool did_assert() {
  if (!assert_disabled_for_test) {
    print_string("not waiting for assert\n");
    assert(false);
    return false;
  }
  assert_disabled_for_test = false;
  return would_fail_assert;
}

void assert(bool condition) {
  if (assert_disabled_for_test) {
    would_fail_assert = would_fail_assert | !condition;
    return;
  }
  if (condition) {
    return;
  }
  var a = new int[0]{i -> 0};
  a[123456789] = 1;
  return;
}

bool str_eq(string a, string b) {
  var a_len = length_of_string(a);
  var b_len = length_of_string(b);
  if (a_len != b_len) {
    return false;
  }

  var a_chars = array_of_string(a);
  var b_chars = array_of_string(b);

  for (var i = 0; i < a_len; i = i + 1;) {
    if (a_chars[i] != b_chars[i]) {
      return false;
    }
  }
  return true;
}

Json wrap_obj(JsonObject obj){
  return new Json {
    obj = obj;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_arr(JsonArray arr){
  return new Json {
    obj = JsonObject null;
    arr = arr;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_str(JsonString str){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = str;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_number(JsonNumber number){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = number;
    boolean = JsonBoolean null;
    nil = JsonNull null
  };
}

Json wrap_boolean(JsonBoolean boolean){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = boolean;
    nil = JsonNull null
  };
}

Json wrap_nil(JsonNull nil){
  return new Json {
    obj = JsonObject null;
    arr = JsonArray null;
    str = JsonString null;
    number = JsonNumber null;
    boolean = JsonBoolean null;
    nil = nil
  };
}

void test_null(){
  assert(str_eq(
    print_json(wrap_nil(new JsonNull {})), "null"
  ));
  return;
}

void test_parse_str() {
  var state = parse_state_of_string("walrus");
  assert(length(state.str) == 6);
  assert(state.pos == 0);

  /* Case: Typical parse */
  var output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  });
  assert(str_eq(output, "wal"));
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "r";
    count = 1
  });
  assert(str_eq(output, "r"));
  assert(state.pos == 4);

  /* Case: Count does not match string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 2
  });
  assert(did_assert());

  /* Case: Null string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Empty string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_str(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  });
  assert(did_assert());

  /* Case: Also contains JSON node */
  await_assert();
  output = must_parse_str(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wal";
    count = 3
  });
  assert(did_assert());

  return;
}

void test_parse_node() {
  /* Case: Typical */
  var state = parse_state_of_string("walrus");
  var output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  });
  assert(state.pos == 3);

  /* Case: Continues from existing parse state */
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 1
  });
  assert(state.pos == 4);

  /* Case: Null node */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 2
  });
  assert(did_assert());

  /* Case: Also contains string */
  await_assert();
  state = parse_state_of_string("walrus");
  output = must_parse_node(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = "wa";
    count = 2
  });
  assert(did_assert());

  return;
}

void test_can_parse_some() {
  var state = parse_state_of_string("walrus");

  /* Case: Typical node */
  assert(can_parse_some(new ParseResult {
    input = state;
    node = wrap_nil(new JsonNull {});
    str = string null;
    count = 3
  }));

  /* Case: Typical string */
  assert(can_parse_some(new ParseResult {
    input = state;
    node = Json null;
    str = "wal";
    count = 3
  }));

  /* Case: Empty string */
  assert(!can_parse_some(new ParseResult {
    input = state;
    node = Json null;
    str = "";
    count = 0
  }));

  /* Case: Totally empty */
  assert(!can_parse_some(new ParseResult {
    input = state;
    node = Json null;
    str = string null;
    count = 0
  }));

  return;
}

void test_vector() {
  var vec = int_vector_new();
  assert(vec.len == 0);
  vec = int_vector_append(vec, 1);
  vec = int_vector_append(vec, 8);
  vec = int_vector_append(vec, 3);
  assert(vec.len == 3);
  assert(vec.data[0] == 1);
  assert(vec.data[1] == 8);
  assert(vec.data[2] == 3);
  for (var i = 0; i < 100; i = i + 1;) {
    vec = int_vector_append(vec, 7);
  }
  assert(vec.len == 103);
  assert(vec.data[102] == 7);
  return;
}

void run_tests() {
  test_null();
  test_parse_str();
  test_parse_node();
  test_can_parse_some();
  test_vector();

  if (assert_disabled_for_test) {
    /* await_assert() without matching did_assert() */
    assert_disabled_for_test = false;
    assert(false);
  }
  return;
}

int program(int argc, string[] argv) {
  run_tests();
  print_string("PASSED");

  var input = convert_quotes("
    {'menu': {
      'id': 'file',
      'value': 'File',
      'popup': {
        'menuitem': [
          {'value': 'New', 'onclick': 'CreateNewDoc()'},
          {'value': 'Open', 'onclick': 'OpenDoc()'},
          {'value': 'Close', 'onclick': 'CloseDoc()'}
        ]
      }
    }}
  ");
  /* print_string(input); */

  return 0;
}